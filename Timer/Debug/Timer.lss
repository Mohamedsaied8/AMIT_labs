
Timer.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005e0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  000005e0  00000674  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000002a  00800062  00800062  00000676  2**0
                  ALLOC
  3 .stab         00000ce4  00000000  00000000  00000678  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000c60  00000000  00000000  0000135c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 84 02 	jmp	0x508	; 0x508 <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 ee       	ldi	r30, 0xE0	; 224
  68:	f5 e0       	ldi	r31, 0x05	; 5
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a2 36       	cpi	r26, 0x62	; 98
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a2 e6       	ldi	r26, 0x62	; 98
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ac 38       	cpi	r26, 0x8C	; 140
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 64 02 	call	0x4c8	; 0x4c8 <main>
  8a:	0c 94 ee 02 	jmp	0x5dc	; 0x5dc <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <SchedulerInit>:
  92:	df 93       	push	r29
  94:	cf 93       	push	r28
  96:	0f 92       	push	r0
  98:	cd b7       	in	r28, 0x3d	; 61
  9a:	de b7       	in	r29, 0x3e	; 62
  9c:	19 82       	std	Y+1, r1	; 0x01
  9e:	48 c0       	rjmp	.+144    	; 0x130 <SchedulerInit+0x9e>
  a0:	89 81       	ldd	r24, Y+1	; 0x01
  a2:	88 2f       	mov	r24, r24
  a4:	90 e0       	ldi	r25, 0x00	; 0
  a6:	88 0f       	add	r24, r24
  a8:	99 1f       	adc	r25, r25
  aa:	88 0f       	add	r24, r24
  ac:	99 1f       	adc	r25, r25
  ae:	88 0f       	add	r24, r24
  b0:	99 1f       	adc	r25, r25
  b2:	fc 01       	movw	r30, r24
  b4:	ec 59       	subi	r30, 0x9C	; 156
  b6:	ff 4f       	sbci	r31, 0xFF	; 255
  b8:	10 82       	st	Z, r1
  ba:	89 81       	ldd	r24, Y+1	; 0x01
  bc:	88 2f       	mov	r24, r24
  be:	90 e0       	ldi	r25, 0x00	; 0
  c0:	88 0f       	add	r24, r24
  c2:	99 1f       	adc	r25, r25
  c4:	88 0f       	add	r24, r24
  c6:	99 1f       	adc	r25, r25
  c8:	88 0f       	add	r24, r24
  ca:	99 1f       	adc	r25, r25
  cc:	fc 01       	movw	r30, r24
  ce:	eb 59       	subi	r30, 0x9B	; 155
  d0:	ff 4f       	sbci	r31, 0xFF	; 255
  d2:	11 82       	std	Z+1, r1	; 0x01
  d4:	10 82       	st	Z, r1
  d6:	89 81       	ldd	r24, Y+1	; 0x01
  d8:	88 2f       	mov	r24, r24
  da:	90 e0       	ldi	r25, 0x00	; 0
  dc:	88 0f       	add	r24, r24
  de:	99 1f       	adc	r25, r25
  e0:	88 0f       	add	r24, r24
  e2:	99 1f       	adc	r25, r25
  e4:	88 0f       	add	r24, r24
  e6:	99 1f       	adc	r25, r25
  e8:	fc 01       	movw	r30, r24
  ea:	e9 59       	subi	r30, 0x99	; 153
  ec:	ff 4f       	sbci	r31, 0xFF	; 255
  ee:	11 82       	std	Z+1, r1	; 0x01
  f0:	10 82       	st	Z, r1
  f2:	89 81       	ldd	r24, Y+1	; 0x01
  f4:	88 2f       	mov	r24, r24
  f6:	90 e0       	ldi	r25, 0x00	; 0
  f8:	88 0f       	add	r24, r24
  fa:	99 1f       	adc	r25, r25
  fc:	88 0f       	add	r24, r24
  fe:	99 1f       	adc	r25, r25
 100:	88 0f       	add	r24, r24
 102:	99 1f       	adc	r25, r25
 104:	fc 01       	movw	r30, r24
 106:	e7 59       	subi	r30, 0x97	; 151
 108:	ff 4f       	sbci	r31, 0xFF	; 255
 10a:	11 82       	std	Z+1, r1	; 0x01
 10c:	10 82       	st	Z, r1
 10e:	89 81       	ldd	r24, Y+1	; 0x01
 110:	88 2f       	mov	r24, r24
 112:	90 e0       	ldi	r25, 0x00	; 0
 114:	88 0f       	add	r24, r24
 116:	99 1f       	adc	r25, r25
 118:	88 0f       	add	r24, r24
 11a:	99 1f       	adc	r25, r25
 11c:	88 0f       	add	r24, r24
 11e:	99 1f       	adc	r25, r25
 120:	fc 01       	movw	r30, r24
 122:	e5 59       	subi	r30, 0x95	; 149
 124:	ff 4f       	sbci	r31, 0xFF	; 255
 126:	82 e0       	ldi	r24, 0x02	; 2
 128:	80 83       	st	Z, r24
 12a:	89 81       	ldd	r24, Y+1	; 0x01
 12c:	8f 5f       	subi	r24, 0xFF	; 255
 12e:	89 83       	std	Y+1, r24	; 0x01
 130:	89 81       	ldd	r24, Y+1	; 0x01
 132:	85 30       	cpi	r24, 0x05	; 5
 134:	08 f4       	brcc	.+2      	; 0x138 <SchedulerInit+0xa6>
 136:	b4 cf       	rjmp	.-152    	; 0xa0 <SchedulerInit+0xe>
 138:	0f 90       	pop	r0
 13a:	cf 91       	pop	r28
 13c:	df 91       	pop	r29
 13e:	08 95       	ret

00000140 <addTask>:
}
/*
 * add task to the task list
 * find the next empty id and then place the task parameters
 */
void addTask(uint8_t id,task_t task,uint16_t period){
 140:	df 93       	push	r29
 142:	cf 93       	push	r28
 144:	cd b7       	in	r28, 0x3d	; 61
 146:	de b7       	in	r29, 0x3e	; 62
 148:	27 97       	sbiw	r28, 0x07	; 7
 14a:	0f b6       	in	r0, 0x3f	; 63
 14c:	f8 94       	cli
 14e:	de bf       	out	0x3e, r29	; 62
 150:	0f be       	out	0x3f, r0	; 63
 152:	cd bf       	out	0x3d, r28	; 61
 154:	8b 83       	std	Y+3, r24	; 0x03
 156:	7d 83       	std	Y+5, r23	; 0x05
 158:	6c 83       	std	Y+4, r22	; 0x04
 15a:	5f 83       	std	Y+7, r21	; 0x07
 15c:	4e 83       	std	Y+6, r20	; 0x06
		uint8_t done=0;
 15e:	1a 82       	std	Y+2, r1	; 0x02
		for(uint8_t idx=0;idx<TASKS_MAX;idx++)
 160:	19 82       	std	Y+1, r1	; 0x01
 162:	63 c0       	rjmp	.+198    	; 0x22a <addTask+0xea>
		{
			if(task_list[idx].status==STOPPED)
 164:	89 81       	ldd	r24, Y+1	; 0x01
 166:	88 2f       	mov	r24, r24
 168:	90 e0       	ldi	r25, 0x00	; 0
 16a:	88 0f       	add	r24, r24
 16c:	99 1f       	adc	r25, r25
 16e:	88 0f       	add	r24, r24
 170:	99 1f       	adc	r25, r25
 172:	88 0f       	add	r24, r24
 174:	99 1f       	adc	r25, r25
 176:	fc 01       	movw	r30, r24
 178:	e5 59       	subi	r30, 0x95	; 149
 17a:	ff 4f       	sbci	r31, 0xFF	; 255
 17c:	80 81       	ld	r24, Z
 17e:	82 30       	cpi	r24, 0x02	; 2
 180:	09 f0       	breq	.+2      	; 0x184 <addTask+0x44>
 182:	4d c0       	rjmp	.+154    	; 0x21e <addTask+0xde>
			{
				task_list[idx].id=id;
 184:	89 81       	ldd	r24, Y+1	; 0x01
 186:	88 2f       	mov	r24, r24
 188:	90 e0       	ldi	r25, 0x00	; 0
 18a:	88 0f       	add	r24, r24
 18c:	99 1f       	adc	r25, r25
 18e:	88 0f       	add	r24, r24
 190:	99 1f       	adc	r25, r25
 192:	88 0f       	add	r24, r24
 194:	99 1f       	adc	r25, r25
 196:	fc 01       	movw	r30, r24
 198:	ec 59       	subi	r30, 0x9C	; 156
 19a:	ff 4f       	sbci	r31, 0xFF	; 255
 19c:	8b 81       	ldd	r24, Y+3	; 0x03
 19e:	80 83       	st	Z, r24
				task_list[idx].task=task;
 1a0:	89 81       	ldd	r24, Y+1	; 0x01
 1a2:	88 2f       	mov	r24, r24
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	88 0f       	add	r24, r24
 1a8:	99 1f       	adc	r25, r25
 1aa:	88 0f       	add	r24, r24
 1ac:	99 1f       	adc	r25, r25
 1ae:	88 0f       	add	r24, r24
 1b0:	99 1f       	adc	r25, r25
 1b2:	fc 01       	movw	r30, r24
 1b4:	eb 59       	subi	r30, 0x9B	; 155
 1b6:	ff 4f       	sbci	r31, 0xFF	; 255
 1b8:	8c 81       	ldd	r24, Y+4	; 0x04
 1ba:	9d 81       	ldd	r25, Y+5	; 0x05
 1bc:	91 83       	std	Z+1, r25	; 0x01
 1be:	80 83       	st	Z, r24
				task_list[idx].delay=period;
 1c0:	89 81       	ldd	r24, Y+1	; 0x01
 1c2:	88 2f       	mov	r24, r24
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	88 0f       	add	r24, r24
 1c8:	99 1f       	adc	r25, r25
 1ca:	88 0f       	add	r24, r24
 1cc:	99 1f       	adc	r25, r25
 1ce:	88 0f       	add	r24, r24
 1d0:	99 1f       	adc	r25, r25
 1d2:	fc 01       	movw	r30, r24
 1d4:	e9 59       	subi	r30, 0x99	; 153
 1d6:	ff 4f       	sbci	r31, 0xFF	; 255
 1d8:	8e 81       	ldd	r24, Y+6	; 0x06
 1da:	9f 81       	ldd	r25, Y+7	; 0x07
 1dc:	91 83       	std	Z+1, r25	; 0x01
 1de:	80 83       	st	Z, r24
				task_list[idx].period=period;
 1e0:	89 81       	ldd	r24, Y+1	; 0x01
 1e2:	88 2f       	mov	r24, r24
 1e4:	90 e0       	ldi	r25, 0x00	; 0
 1e6:	88 0f       	add	r24, r24
 1e8:	99 1f       	adc	r25, r25
 1ea:	88 0f       	add	r24, r24
 1ec:	99 1f       	adc	r25, r25
 1ee:	88 0f       	add	r24, r24
 1f0:	99 1f       	adc	r25, r25
 1f2:	fc 01       	movw	r30, r24
 1f4:	e7 59       	subi	r30, 0x97	; 151
 1f6:	ff 4f       	sbci	r31, 0xFF	; 255
 1f8:	8e 81       	ldd	r24, Y+6	; 0x06
 1fa:	9f 81       	ldd	r25, Y+7	; 0x07
 1fc:	91 83       	std	Z+1, r25	; 0x01
 1fe:	80 83       	st	Z, r24
				task_list[idx].status=READY;
 200:	89 81       	ldd	r24, Y+1	; 0x01
 202:	88 2f       	mov	r24, r24
 204:	90 e0       	ldi	r25, 0x00	; 0
 206:	88 0f       	add	r24, r24
 208:	99 1f       	adc	r25, r25
 20a:	88 0f       	add	r24, r24
 20c:	99 1f       	adc	r25, r25
 20e:	88 0f       	add	r24, r24
 210:	99 1f       	adc	r25, r25
 212:	fc 01       	movw	r30, r24
 214:	e5 59       	subi	r30, 0x95	; 149
 216:	ff 4f       	sbci	r31, 0xFF	; 255
 218:	10 82       	st	Z, r1
				done=1;
 21a:	81 e0       	ldi	r24, 0x01	; 1
 21c:	8a 83       	std	Y+2, r24	; 0x02
			}
			if(done!=0)break;
 21e:	8a 81       	ldd	r24, Y+2	; 0x02
 220:	88 23       	and	r24, r24
 222:	39 f4       	brne	.+14     	; 0x232 <addTask+0xf2>
 * add task to the task list
 * find the next empty id and then place the task parameters
 */
void addTask(uint8_t id,task_t task,uint16_t period){
		uint8_t done=0;
		for(uint8_t idx=0;idx<TASKS_MAX;idx++)
 224:	89 81       	ldd	r24, Y+1	; 0x01
 226:	8f 5f       	subi	r24, 0xFF	; 255
 228:	89 83       	std	Y+1, r24	; 0x01
 22a:	89 81       	ldd	r24, Y+1	; 0x01
 22c:	85 30       	cpi	r24, 0x05	; 5
 22e:	08 f4       	brcc	.+2      	; 0x232 <addTask+0xf2>
 230:	99 cf       	rjmp	.-206    	; 0x164 <addTask+0x24>
				task_list[idx].status=READY;
				done=1;
			}
			if(done!=0)break;
		}
}
 232:	27 96       	adiw	r28, 0x07	; 7
 234:	0f b6       	in	r0, 0x3f	; 63
 236:	f8 94       	cli
 238:	de bf       	out	0x3e, r29	; 62
 23a:	0f be       	out	0x3f, r0	; 63
 23c:	cd bf       	out	0x3d, r28	; 61
 23e:	cf 91       	pop	r28
 240:	df 91       	pop	r29
 242:	08 95       	ret

00000244 <delteTask>:
/*
 * deleteTask
 * find the id of the task
 * change status to be STOPPED
 */
 void delteTask(uint8_t id){
 244:	df 93       	push	r29
 246:	cf 93       	push	r28
 248:	00 d0       	rcall	.+0      	; 0x24a <delteTask+0x6>
 24a:	cd b7       	in	r28, 0x3d	; 61
 24c:	de b7       	in	r29, 0x3e	; 62
 24e:	8a 83       	std	Y+2, r24	; 0x02
	 for(uint8_t idx=0;idx<TASKS_MAX;idx++)
 250:	19 82       	std	Y+1, r1	; 0x01
 252:	22 c0       	rjmp	.+68     	; 0x298 <delteTask+0x54>
	 		{
	 			if(task_list[idx].id==id)
 254:	89 81       	ldd	r24, Y+1	; 0x01
 256:	88 2f       	mov	r24, r24
 258:	90 e0       	ldi	r25, 0x00	; 0
 25a:	88 0f       	add	r24, r24
 25c:	99 1f       	adc	r25, r25
 25e:	88 0f       	add	r24, r24
 260:	99 1f       	adc	r25, r25
 262:	88 0f       	add	r24, r24
 264:	99 1f       	adc	r25, r25
 266:	fc 01       	movw	r30, r24
 268:	ec 59       	subi	r30, 0x9C	; 156
 26a:	ff 4f       	sbci	r31, 0xFF	; 255
 26c:	90 81       	ld	r25, Z
 26e:	8a 81       	ldd	r24, Y+2	; 0x02
 270:	98 17       	cp	r25, r24
 272:	79 f4       	brne	.+30     	; 0x292 <delteTask+0x4e>
	 			{
	 				task_list[idx].status=STOPPED;
 274:	89 81       	ldd	r24, Y+1	; 0x01
 276:	88 2f       	mov	r24, r24
 278:	90 e0       	ldi	r25, 0x00	; 0
 27a:	88 0f       	add	r24, r24
 27c:	99 1f       	adc	r25, r25
 27e:	88 0f       	add	r24, r24
 280:	99 1f       	adc	r25, r25
 282:	88 0f       	add	r24, r24
 284:	99 1f       	adc	r25, r25
 286:	fc 01       	movw	r30, r24
 288:	e5 59       	subi	r30, 0x95	; 149
 28a:	ff 4f       	sbci	r31, 0xFF	; 255
 28c:	82 e0       	ldi	r24, 0x02	; 2
 28e:	80 83       	st	Z, r24
 290:	06 c0       	rjmp	.+12     	; 0x29e <delteTask+0x5a>
 * deleteTask
 * find the id of the task
 * change status to be STOPPED
 */
 void delteTask(uint8_t id){
	 for(uint8_t idx=0;idx<TASKS_MAX;idx++)
 292:	89 81       	ldd	r24, Y+1	; 0x01
 294:	8f 5f       	subi	r24, 0xFF	; 255
 296:	89 83       	std	Y+1, r24	; 0x01
 298:	89 81       	ldd	r24, Y+1	; 0x01
 29a:	85 30       	cpi	r24, 0x05	; 5
 29c:	d8 f2       	brcs	.-74     	; 0x254 <delteTask+0x10>
	 				task_list[idx].status=STOPPED;
	 				break;
	 			}
	 		}

 }
 29e:	0f 90       	pop	r0
 2a0:	0f 90       	pop	r0
 2a2:	cf 91       	pop	r28
 2a4:	df 91       	pop	r29
 2a6:	08 95       	ret

000002a8 <getStatus>:
 /*
  * Get Status of a Task
  * find the ID of a Task return the status
  */
 status_t getStatus(uint8_t id){
 2a8:	df 93       	push	r29
 2aa:	cf 93       	push	r28
 2ac:	00 d0       	rcall	.+0      	; 0x2ae <getStatus+0x6>
 2ae:	0f 92       	push	r0
 2b0:	cd b7       	in	r28, 0x3d	; 61
 2b2:	de b7       	in	r29, 0x3e	; 62
 2b4:	8a 83       	std	Y+2, r24	; 0x02
	 for(uint8_t idx=0;idx<TASKS_MAX;idx++)
 2b6:	19 82       	std	Y+1, r1	; 0x01
 2b8:	22 c0       	rjmp	.+68     	; 0x2fe <getStatus+0x56>
	 {
		 if(task_list[idx].id==id)
 2ba:	89 81       	ldd	r24, Y+1	; 0x01
 2bc:	88 2f       	mov	r24, r24
 2be:	90 e0       	ldi	r25, 0x00	; 0
 2c0:	88 0f       	add	r24, r24
 2c2:	99 1f       	adc	r25, r25
 2c4:	88 0f       	add	r24, r24
 2c6:	99 1f       	adc	r25, r25
 2c8:	88 0f       	add	r24, r24
 2ca:	99 1f       	adc	r25, r25
 2cc:	fc 01       	movw	r30, r24
 2ce:	ec 59       	subi	r30, 0x9C	; 156
 2d0:	ff 4f       	sbci	r31, 0xFF	; 255
 2d2:	90 81       	ld	r25, Z
 2d4:	8a 81       	ldd	r24, Y+2	; 0x02
 2d6:	98 17       	cp	r25, r24
 2d8:	79 f4       	brne	.+30     	; 0x2f8 <getStatus+0x50>
		 return task_list[idx].status;
 2da:	89 81       	ldd	r24, Y+1	; 0x01
 2dc:	88 2f       	mov	r24, r24
 2de:	90 e0       	ldi	r25, 0x00	; 0
 2e0:	88 0f       	add	r24, r24
 2e2:	99 1f       	adc	r25, r25
 2e4:	88 0f       	add	r24, r24
 2e6:	99 1f       	adc	r25, r25
 2e8:	88 0f       	add	r24, r24
 2ea:	99 1f       	adc	r25, r25
 2ec:	fc 01       	movw	r30, r24
 2ee:	e5 59       	subi	r30, 0x95	; 149
 2f0:	ff 4f       	sbci	r31, 0xFF	; 255
 2f2:	80 81       	ld	r24, Z
 2f4:	8b 83       	std	Y+3, r24	; 0x03
 2f6:	08 c0       	rjmp	.+16     	; 0x308 <getStatus+0x60>
 /*
  * Get Status of a Task
  * find the ID of a Task return the status
  */
 status_t getStatus(uint8_t id){
	 for(uint8_t idx=0;idx<TASKS_MAX;idx++)
 2f8:	89 81       	ldd	r24, Y+1	; 0x01
 2fa:	8f 5f       	subi	r24, 0xFF	; 255
 2fc:	89 83       	std	Y+1, r24	; 0x01
 2fe:	89 81       	ldd	r24, Y+1	; 0x01
 300:	85 30       	cpi	r24, 0x05	; 5
 302:	d8 f2       	brcs	.-74     	; 0x2ba <getStatus+0x12>
	 {
		 if(task_list[idx].id==id)
		 return task_list[idx].status;
	 }
	 return ERROR;
 304:	83 e0       	ldi	r24, 0x03	; 3
 306:	8b 83       	std	Y+3, r24	; 0x03
 308:	8b 81       	ldd	r24, Y+3	; 0x03
 }
 30a:	0f 90       	pop	r0
 30c:	0f 90       	pop	r0
 30e:	0f 90       	pop	r0
 310:	cf 91       	pop	r28
 312:	df 91       	pop	r29
 314:	08 95       	ret

00000316 <dispatchTasks>:
/*
 * Dispatch
 *
 */
void dispatchTasks(){
 316:	df 93       	push	r29
 318:	cf 93       	push	r28
 31a:	0f 92       	push	r0
 31c:	cd b7       	in	r28, 0x3d	; 61
 31e:	de b7       	in	r29, 0x3e	; 62
	 for(uint8_t idx=0;idx<TASKS_MAX;idx++)
 320:	19 82       	std	Y+1, r1	; 0x01
 322:	6c c0       	rjmp	.+216    	; 0x3fc <dispatchTasks+0xe6>
	 	{
		 if(!task_list[idx].delay && task_list[idx].status==READY){
 324:	89 81       	ldd	r24, Y+1	; 0x01
 326:	88 2f       	mov	r24, r24
 328:	90 e0       	ldi	r25, 0x00	; 0
 32a:	88 0f       	add	r24, r24
 32c:	99 1f       	adc	r25, r25
 32e:	88 0f       	add	r24, r24
 330:	99 1f       	adc	r25, r25
 332:	88 0f       	add	r24, r24
 334:	99 1f       	adc	r25, r25
 336:	fc 01       	movw	r30, r24
 338:	e9 59       	subi	r30, 0x99	; 153
 33a:	ff 4f       	sbci	r31, 0xFF	; 255
 33c:	80 81       	ld	r24, Z
 33e:	91 81       	ldd	r25, Z+1	; 0x01
 340:	00 97       	sbiw	r24, 0x00	; 0
 342:	09 f0       	breq	.+2      	; 0x346 <dispatchTasks+0x30>
 344:	58 c0       	rjmp	.+176    	; 0x3f6 <dispatchTasks+0xe0>
 346:	89 81       	ldd	r24, Y+1	; 0x01
 348:	88 2f       	mov	r24, r24
 34a:	90 e0       	ldi	r25, 0x00	; 0
 34c:	88 0f       	add	r24, r24
 34e:	99 1f       	adc	r25, r25
 350:	88 0f       	add	r24, r24
 352:	99 1f       	adc	r25, r25
 354:	88 0f       	add	r24, r24
 356:	99 1f       	adc	r25, r25
 358:	fc 01       	movw	r30, r24
 35a:	e5 59       	subi	r30, 0x95	; 149
 35c:	ff 4f       	sbci	r31, 0xFF	; 255
 35e:	80 81       	ld	r24, Z
 360:	88 23       	and	r24, r24
 362:	09 f0       	breq	.+2      	; 0x366 <dispatchTasks+0x50>
 364:	48 c0       	rjmp	.+144    	; 0x3f6 <dispatchTasks+0xe0>
			 //make the status is running
		 		task_list[idx].status=RUNNING;
 366:	89 81       	ldd	r24, Y+1	; 0x01
 368:	88 2f       	mov	r24, r24
 36a:	90 e0       	ldi	r25, 0x00	; 0
 36c:	88 0f       	add	r24, r24
 36e:	99 1f       	adc	r25, r25
 370:	88 0f       	add	r24, r24
 372:	99 1f       	adc	r25, r25
 374:	88 0f       	add	r24, r24
 376:	99 1f       	adc	r25, r25
 378:	fc 01       	movw	r30, r24
 37a:	e5 59       	subi	r30, 0x95	; 149
 37c:	ff 4f       	sbci	r31, 0xFF	; 255
 37e:	81 e0       	ldi	r24, 0x01	; 1
 380:	80 83       	st	Z, r24
			 //call the task function
		 		(*task_list[idx].task)();
 382:	89 81       	ldd	r24, Y+1	; 0x01
 384:	88 2f       	mov	r24, r24
 386:	90 e0       	ldi	r25, 0x00	; 0
 388:	88 0f       	add	r24, r24
 38a:	99 1f       	adc	r25, r25
 38c:	88 0f       	add	r24, r24
 38e:	99 1f       	adc	r25, r25
 390:	88 0f       	add	r24, r24
 392:	99 1f       	adc	r25, r25
 394:	fc 01       	movw	r30, r24
 396:	eb 59       	subi	r30, 0x9B	; 155
 398:	ff 4f       	sbci	r31, 0xFF	; 255
 39a:	01 90       	ld	r0, Z+
 39c:	f0 81       	ld	r31, Z
 39e:	e0 2d       	mov	r30, r0
 3a0:	09 95       	icall
		 		//Reset period
		 		task_list[idx].delay=task_list[idx].period;
 3a2:	89 81       	ldd	r24, Y+1	; 0x01
 3a4:	48 2f       	mov	r20, r24
 3a6:	50 e0       	ldi	r21, 0x00	; 0
 3a8:	89 81       	ldd	r24, Y+1	; 0x01
 3aa:	88 2f       	mov	r24, r24
 3ac:	90 e0       	ldi	r25, 0x00	; 0
 3ae:	88 0f       	add	r24, r24
 3b0:	99 1f       	adc	r25, r25
 3b2:	88 0f       	add	r24, r24
 3b4:	99 1f       	adc	r25, r25
 3b6:	88 0f       	add	r24, r24
 3b8:	99 1f       	adc	r25, r25
 3ba:	fc 01       	movw	r30, r24
 3bc:	e7 59       	subi	r30, 0x97	; 151
 3be:	ff 4f       	sbci	r31, 0xFF	; 255
 3c0:	20 81       	ld	r18, Z
 3c2:	31 81       	ldd	r19, Z+1	; 0x01
 3c4:	ca 01       	movw	r24, r20
 3c6:	88 0f       	add	r24, r24
 3c8:	99 1f       	adc	r25, r25
 3ca:	88 0f       	add	r24, r24
 3cc:	99 1f       	adc	r25, r25
 3ce:	88 0f       	add	r24, r24
 3d0:	99 1f       	adc	r25, r25
 3d2:	fc 01       	movw	r30, r24
 3d4:	e9 59       	subi	r30, 0x99	; 153
 3d6:	ff 4f       	sbci	r31, 0xFF	; 255
 3d8:	31 83       	std	Z+1, r19	; 0x01
 3da:	20 83       	st	Z, r18
			 //change the status again to be READY after function finishes
		 		task_list[idx].status=READY;
 3dc:	89 81       	ldd	r24, Y+1	; 0x01
 3de:	88 2f       	mov	r24, r24
 3e0:	90 e0       	ldi	r25, 0x00	; 0
 3e2:	88 0f       	add	r24, r24
 3e4:	99 1f       	adc	r25, r25
 3e6:	88 0f       	add	r24, r24
 3e8:	99 1f       	adc	r25, r25
 3ea:	88 0f       	add	r24, r24
 3ec:	99 1f       	adc	r25, r25
 3ee:	fc 01       	movw	r30, r24
 3f0:	e5 59       	subi	r30, 0x95	; 149
 3f2:	ff 4f       	sbci	r31, 0xFF	; 255
 3f4:	10 82       	st	Z, r1
/*
 * Dispatch
 *
 */
void dispatchTasks(){
	 for(uint8_t idx=0;idx<TASKS_MAX;idx++)
 3f6:	89 81       	ldd	r24, Y+1	; 0x01
 3f8:	8f 5f       	subi	r24, 0xFF	; 255
 3fa:	89 83       	std	Y+1, r24	; 0x01
 3fc:	89 81       	ldd	r24, Y+1	; 0x01
 3fe:	85 30       	cpi	r24, 0x05	; 5
 400:	08 f4       	brcc	.+2      	; 0x404 <dispatchTasks+0xee>
 402:	90 cf       	rjmp	.-224    	; 0x324 <dispatchTasks+0xe>
		 		task_list[idx].delay=task_list[idx].period;
			 //change the status again to be READY after function finishes
		 		task_list[idx].status=READY;
		 }
	 	}
}
 404:	0f 90       	pop	r0
 406:	cf 91       	pop	r28
 408:	df 91       	pop	r29
 40a:	08 95       	ret

0000040c <Task1>:

#define LED1	7
#define LED0	2

void Task1(void)
{
 40c:	df 93       	push	r29
 40e:	cf 93       	push	r28
 410:	0f 92       	push	r0
 412:	cd b7       	in	r28, 0x3d	; 61
 414:	de b7       	in	r29, 0x3e	; 62
    static uint8_t status = 0x01;
    if(status)
 416:	80 91 60 00 	lds	r24, 0x0060
 41a:	88 23       	and	r24, r24
 41c:	41 f0       	breq	.+16     	; 0x42e <Task1+0x22>
        PORTC |= (1<<LED0);
 41e:	a5 e3       	ldi	r26, 0x35	; 53
 420:	b0 e0       	ldi	r27, 0x00	; 0
 422:	e5 e3       	ldi	r30, 0x35	; 53
 424:	f0 e0       	ldi	r31, 0x00	; 0
 426:	80 81       	ld	r24, Z
 428:	84 60       	ori	r24, 0x04	; 4
 42a:	8c 93       	st	X, r24
 42c:	07 c0       	rjmp	.+14     	; 0x43c <Task1+0x30>
    else
        PORTC &= ~(1<<LED0);
 42e:	a5 e3       	ldi	r26, 0x35	; 53
 430:	b0 e0       	ldi	r27, 0x00	; 0
 432:	e5 e3       	ldi	r30, 0x35	; 53
 434:	f0 e0       	ldi	r31, 0x00	; 0
 436:	80 81       	ld	r24, Z
 438:	8b 7f       	andi	r24, 0xFB	; 251
 43a:	8c 93       	st	X, r24
    status = !status;
 43c:	80 91 60 00 	lds	r24, 0x0060
 440:	19 82       	std	Y+1, r1	; 0x01
 442:	88 23       	and	r24, r24
 444:	11 f4       	brne	.+4      	; 0x44a <Task1+0x3e>
 446:	81 e0       	ldi	r24, 0x01	; 1
 448:	89 83       	std	Y+1, r24	; 0x01
 44a:	89 81       	ldd	r24, Y+1	; 0x01
 44c:	80 93 60 00 	sts	0x0060, r24
}
 450:	0f 90       	pop	r0
 452:	cf 91       	pop	r28
 454:	df 91       	pop	r29
 456:	08 95       	ret

00000458 <Task2>:


void Task2(void)
{
 458:	df 93       	push	r29
 45a:	cf 93       	push	r28
 45c:	0f 92       	push	r0
 45e:	cd b7       	in	r28, 0x3d	; 61
 460:	de b7       	in	r29, 0x3e	; 62
    static uint8_t status = 0x01;
    if( status )
 462:	80 91 61 00 	lds	r24, 0x0061
 466:	88 23       	and	r24, r24
 468:	41 f0       	breq	.+16     	; 0x47a <Task2+0x22>
        PORTC|= (1<<LED1);
 46a:	a5 e3       	ldi	r26, 0x35	; 53
 46c:	b0 e0       	ldi	r27, 0x00	; 0
 46e:	e5 e3       	ldi	r30, 0x35	; 53
 470:	f0 e0       	ldi	r31, 0x00	; 0
 472:	80 81       	ld	r24, Z
 474:	80 68       	ori	r24, 0x80	; 128
 476:	8c 93       	st	X, r24
 478:	07 c0       	rjmp	.+14     	; 0x488 <Task2+0x30>
    else
        PORTC &= ~(1<<LED1);
 47a:	a5 e3       	ldi	r26, 0x35	; 53
 47c:	b0 e0       	ldi	r27, 0x00	; 0
 47e:	e5 e3       	ldi	r30, 0x35	; 53
 480:	f0 e0       	ldi	r31, 0x00	; 0
 482:	80 81       	ld	r24, Z
 484:	8f 77       	andi	r24, 0x7F	; 127
 486:	8c 93       	st	X, r24
    status = !status;
 488:	80 91 61 00 	lds	r24, 0x0061
 48c:	19 82       	std	Y+1, r1	; 0x01
 48e:	88 23       	and	r24, r24
 490:	11 f4       	brne	.+4      	; 0x496 <Task2+0x3e>
 492:	81 e0       	ldi	r24, 0x01	; 1
 494:	89 83       	std	Y+1, r24	; 0x01
 496:	89 81       	ldd	r24, Y+1	; 0x01
 498:	80 93 61 00 	sts	0x0061, r24
}
 49c:	0f 90       	pop	r0
 49e:	cf 91       	pop	r28
 4a0:	df 91       	pop	r29
 4a2:	08 95       	ret

000004a4 <timer_Init>:

void timer_Init(){
 4a4:	df 93       	push	r29
 4a6:	cf 93       	push	r28
 4a8:	cd b7       	in	r28, 0x3d	; 61
 4aa:	de b7       	in	r29, 0x3e	; 62
	 // use 1/8 of system clock frequency
	    TCCR0 = 0x03;//CS02 =0 CS01=1 CS00=1
 4ac:	e3 e5       	ldi	r30, 0x53	; 83
 4ae:	f0 e0       	ldi	r31, 0x00	; 0
 4b0:	83 e0       	ldi	r24, 0x03	; 3
 4b2:	80 83       	st	Z, r24
	    // inital timer value = 0
	    TCNT0 = 0;
 4b4:	e2 e5       	ldi	r30, 0x52	; 82
 4b6:	f0 e0       	ldi	r31, 0x00	; 0
 4b8:	10 82       	st	Z, r1
	    // enable Timer0 Overflow interrupt
	    TIMSK = (1<<0); //TOIE0=bit0
 4ba:	e9 e5       	ldi	r30, 0x59	; 89
 4bc:	f0 e0       	ldi	r31, 0x00	; 0
 4be:	81 e0       	ldi	r24, 0x01	; 1
 4c0:	80 83       	st	Z, r24
}
 4c2:	cf 91       	pop	r28
 4c4:	df 91       	pop	r29
 4c6:	08 95       	ret

000004c8 <main>:
int main(void)
{
 4c8:	df 93       	push	r29
 4ca:	cf 93       	push	r28
 4cc:	cd b7       	in	r28, 0x3d	; 61
 4ce:	de b7       	in	r29, 0x3e	; 62

    // set LED0 bit0 and LED1 on AMIT kit as outputs
    DDRC = (1<<2)|(1<<7);
 4d0:	e4 e3       	ldi	r30, 0x34	; 52
 4d2:	f0 e0       	ldi	r31, 0x00	; 0
 4d4:	84 e8       	ldi	r24, 0x84	; 132
 4d6:	80 83       	st	Z, r24
   // PORTC|=(1<<LED0);
    timer_Init();
 4d8:	0e 94 52 02 	call	0x4a4	; 0x4a4 <timer_Init>
    SchedulerInit();
 4dc:	0e 94 49 00 	call	0x92	; 0x92 <SchedulerInit>
    // add tasks, id is arbitrary
    // task1 runs every 1 second
    addTask(1, Task1, 10);
 4e0:	26 e0       	ldi	r18, 0x06	; 6
 4e2:	32 e0       	ldi	r19, 0x02	; 2
 4e4:	81 e0       	ldi	r24, 0x01	; 1
 4e6:	b9 01       	movw	r22, r18
 4e8:	4a e0       	ldi	r20, 0x0A	; 10
 4ea:	50 e0       	ldi	r21, 0x00	; 0
 4ec:	0e 94 a0 00 	call	0x140	; 0x140 <addTask>

    // task2 runs every 4 seconds
    addTask(2, Task2, 40);
 4f0:	2c e2       	ldi	r18, 0x2C	; 44
 4f2:	32 e0       	ldi	r19, 0x02	; 2
 4f4:	82 e0       	ldi	r24, 0x02	; 2
 4f6:	b9 01       	movw	r22, r18
 4f8:	48 e2       	ldi	r20, 0x28	; 40
 4fa:	50 e0       	ldi	r21, 0x00	; 0
 4fc:	0e 94 a0 00 	call	0x140	; 0x140 <addTask>

    // enable all interrupts
    sei();
 500:	78 94       	sei
    for(;;){
    	//Task1();
    	dispatchTasks();
 502:	0e 94 8b 01 	call	0x316	; 0x316 <dispatchTasks>
 506:	fd cf       	rjmp	.-6      	; 0x502 <main+0x3a>

00000508 <__vector_11>:

/*
 * TIMER0 Interrupt Service Routine(ISR)
 */
//16000000/64=250000=>4us*255=1020=1ms
ISR(TIMER0_OVF_vect){
 508:	1f 92       	push	r1
 50a:	0f 92       	push	r0
 50c:	0f b6       	in	r0, 0x3f	; 63
 50e:	0f 92       	push	r0
 510:	11 24       	eor	r1, r1
 512:	2f 93       	push	r18
 514:	3f 93       	push	r19
 516:	4f 93       	push	r20
 518:	5f 93       	push	r21
 51a:	8f 93       	push	r24
 51c:	9f 93       	push	r25
 51e:	ef 93       	push	r30
 520:	ff 93       	push	r31
 522:	df 93       	push	r29
 524:	cf 93       	push	r28
 526:	0f 92       	push	r0
 528:	cd b7       	in	r28, 0x3d	; 61
 52a:	de b7       	in	r29, 0x3e	; 62
	count++;
 52c:	80 91 62 00 	lds	r24, 0x0062
 530:	90 91 63 00 	lds	r25, 0x0063
 534:	01 96       	adiw	r24, 0x01	; 1
 536:	90 93 63 00 	sts	0x0063, r25
 53a:	80 93 62 00 	sts	0x0062, r24
	if(count==4){
 53e:	80 91 62 00 	lds	r24, 0x0062
 542:	90 91 63 00 	lds	r25, 0x0063
 546:	84 30       	cpi	r24, 0x04	; 4
 548:	91 05       	cpc	r25, r1
 54a:	c1 f5       	brne	.+112    	; 0x5bc <__vector_11+0xb4>
		count=0;
 54c:	10 92 63 00 	sts	0x0063, r1
 550:	10 92 62 00 	sts	0x0062, r1
 554:	30 c0       	rjmp	.+96     	; 0x5b6 <__vector_11+0xae>
		for(uint8_t i;i<TASKS_MAX;i++){
			if(task_list[i].status==READY)
 556:	89 81       	ldd	r24, Y+1	; 0x01
 558:	88 2f       	mov	r24, r24
 55a:	90 e0       	ldi	r25, 0x00	; 0
 55c:	88 0f       	add	r24, r24
 55e:	99 1f       	adc	r25, r25
 560:	88 0f       	add	r24, r24
 562:	99 1f       	adc	r25, r25
 564:	88 0f       	add	r24, r24
 566:	99 1f       	adc	r25, r25
 568:	fc 01       	movw	r30, r24
 56a:	e5 59       	subi	r30, 0x95	; 149
 56c:	ff 4f       	sbci	r31, 0xFF	; 255
 56e:	80 81       	ld	r24, Z
 570:	88 23       	and	r24, r24
 572:	f1 f4       	brne	.+60     	; 0x5b0 <__vector_11+0xa8>
			{
				task_list[i].delay--;
 574:	89 81       	ldd	r24, Y+1	; 0x01
 576:	28 2f       	mov	r18, r24
 578:	30 e0       	ldi	r19, 0x00	; 0
 57a:	c9 01       	movw	r24, r18
 57c:	88 0f       	add	r24, r24
 57e:	99 1f       	adc	r25, r25
 580:	88 0f       	add	r24, r24
 582:	99 1f       	adc	r25, r25
 584:	88 0f       	add	r24, r24
 586:	99 1f       	adc	r25, r25
 588:	fc 01       	movw	r30, r24
 58a:	e9 59       	subi	r30, 0x99	; 153
 58c:	ff 4f       	sbci	r31, 0xFF	; 255
 58e:	80 81       	ld	r24, Z
 590:	91 81       	ldd	r25, Z+1	; 0x01
 592:	ac 01       	movw	r20, r24
 594:	41 50       	subi	r20, 0x01	; 1
 596:	50 40       	sbci	r21, 0x00	; 0
 598:	c9 01       	movw	r24, r18
 59a:	88 0f       	add	r24, r24
 59c:	99 1f       	adc	r25, r25
 59e:	88 0f       	add	r24, r24
 5a0:	99 1f       	adc	r25, r25
 5a2:	88 0f       	add	r24, r24
 5a4:	99 1f       	adc	r25, r25
 5a6:	fc 01       	movw	r30, r24
 5a8:	e9 59       	subi	r30, 0x99	; 153
 5aa:	ff 4f       	sbci	r31, 0xFF	; 255
 5ac:	51 83       	std	Z+1, r21	; 0x01
 5ae:	40 83       	st	Z, r20
//16000000/64=250000=>4us*255=1020=1ms
ISR(TIMER0_OVF_vect){
	count++;
	if(count==4){
		count=0;
		for(uint8_t i;i<TASKS_MAX;i++){
 5b0:	89 81       	ldd	r24, Y+1	; 0x01
 5b2:	8f 5f       	subi	r24, 0xFF	; 255
 5b4:	89 83       	std	Y+1, r24	; 0x01
 5b6:	89 81       	ldd	r24, Y+1	; 0x01
 5b8:	85 30       	cpi	r24, 0x05	; 5
 5ba:	68 f2       	brcs	.-102    	; 0x556 <__vector_11+0x4e>
			{
				task_list[i].delay--;
			}//if
		}//for
	}//if
}//ISR
 5bc:	0f 90       	pop	r0
 5be:	cf 91       	pop	r28
 5c0:	df 91       	pop	r29
 5c2:	ff 91       	pop	r31
 5c4:	ef 91       	pop	r30
 5c6:	9f 91       	pop	r25
 5c8:	8f 91       	pop	r24
 5ca:	5f 91       	pop	r21
 5cc:	4f 91       	pop	r20
 5ce:	3f 91       	pop	r19
 5d0:	2f 91       	pop	r18
 5d2:	0f 90       	pop	r0
 5d4:	0f be       	out	0x3f, r0	; 63
 5d6:	0f 90       	pop	r0
 5d8:	1f 90       	pop	r1
 5da:	18 95       	reti

000005dc <_exit>:
 5dc:	f8 94       	cli

000005de <__stop_program>:
 5de:	ff cf       	rjmp	.-2      	; 0x5de <__stop_program>
