
RTOS_Alarm_Sys_RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001634  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001c  00800060  00001634  000016c8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000462  0080007c  0080007c  000016e4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000016e4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001714  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000310  00000000  00000000  00001750  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000041a7  00000000  00000000  00001a60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000fe8  00000000  00000000  00005c07  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002278  00000000  00000000  00006bef  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000994  00000000  00000000  00008e68  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000149a  00000000  00000000  000097fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000040c7  00000000  00000000  0000ac96  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000388  00000000  00000000  0000ed5d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 70 03 	jmp	0x6e0	; 0x6e0 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e3       	ldi	r30, 0x34	; 52
      68:	f6 e1       	ldi	r31, 0x16	; 22
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 37       	cpi	r26, 0x7C	; 124
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	24 e0       	ldi	r18, 0x04	; 4
      78:	ac e7       	ldi	r26, 0x7C	; 124
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 3d       	cpi	r26, 0xDE	; 222
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 f6 01 	call	0x3ec	; 0x3ec <main>
      8a:	0c 94 18 0b 	jmp	0x1630	; 0x1630 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	cf 93       	push	r28
      98:	df 93       	push	r29
      9a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
      9c:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
      a0:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__data_end>
      a4:	81 11       	cpse	r24, r1
      a6:	1d c0       	rjmp	.+58     	; 0xe2 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
      a8:	e1 e8       	ldi	r30, 0x81	; 129
      aa:	f0 e0       	ldi	r31, 0x00	; 0
      ac:	86 e8       	ldi	r24, 0x86	; 134
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	91 83       	std	Z+1, r25	; 0x01
      b2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
      b4:	13 82       	std	Z+3, r1	; 0x03
      b6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
      b8:	ed e7       	ldi	r30, 0x7D	; 125
      ba:	f0 e0       	ldi	r31, 0x00	; 0
      bc:	87 ee       	ldi	r24, 0xE7	; 231
      be:	93 e0       	ldi	r25, 0x03	; 3
      c0:	93 83       	std	Z+3, r25	; 0x03
      c2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
      c4:	11 82       	std	Z+1, r1	; 0x01
      c6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
      c8:	a5 e8       	ldi	r26, 0x85	; 133
      ca:	b0 e0       	ldi	r27, 0x00	; 0
      cc:	14 96       	adiw	r26, 0x04	; 4
      ce:	9c 93       	st	X, r25
      d0:	8e 93       	st	-X, r24
      d2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
      d4:	12 96       	adiw	r26, 0x02	; 2
      d6:	fc 93       	st	X, r31
      d8:	ee 93       	st	-X, r30
      da:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
      e2:	20 97       	sbiw	r28, 0x00	; 0
      e4:	09 f4       	brne	.+2      	; 0xe8 <pvPortMalloc+0x56>
      e6:	5f c0       	rjmp	.+190    	; 0x1a6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
      e8:	9e 01       	movw	r18, r28
      ea:	2c 5f       	subi	r18, 0xFC	; 252
      ec:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
      ee:	23 96       	adiw	r28, 0x03	; 3
      f0:	c6 3e       	cpi	r28, 0xE6	; 230
      f2:	d3 40       	sbci	r29, 0x03	; 3
      f4:	08 f0       	brcs	.+2      	; 0xf8 <pvPortMalloc+0x66>
      f6:	5a c0       	rjmp	.+180    	; 0x1ac <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
      f8:	e0 91 81 00 	lds	r30, 0x0081	; 0x800081 <xStart>
      fc:	f0 91 82 00 	lds	r31, 0x0082	; 0x800082 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     100:	a1 e8       	ldi	r26, 0x81	; 129
     102:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x78>
     106:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     108:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     10a:	82 81       	ldd	r24, Z+2	; 0x02
     10c:	93 81       	ldd	r25, Z+3	; 0x03
     10e:	82 17       	cp	r24, r18
     110:	93 07       	cpc	r25, r19
     112:	20 f4       	brcc	.+8      	; 0x11c <pvPortMalloc+0x8a>
     114:	80 81       	ld	r24, Z
     116:	91 81       	ldd	r25, Z+1	; 0x01
     118:	00 97       	sbiw	r24, 0x00	; 0
     11a:	a9 f7       	brne	.-22     	; 0x106 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     11c:	c0 e0       	ldi	r28, 0x00	; 0
     11e:	ed 37       	cpi	r30, 0x7D	; 125
     120:	fc 07       	cpc	r31, r28
     122:	09 f4       	brne	.+2      	; 0x126 <pvPortMalloc+0x94>
     124:	46 c0       	rjmp	.+140    	; 0x1b2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     126:	cd 91       	ld	r28, X+
     128:	dc 91       	ld	r29, X
     12a:	11 97       	sbiw	r26, 0x01	; 1
     12c:	8e 01       	movw	r16, r28
     12e:	0c 5f       	subi	r16, 0xFC	; 252
     130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     132:	80 81       	ld	r24, Z
     134:	91 81       	ldd	r25, Z+1	; 0x01
     136:	8d 93       	st	X+, r24
     138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     13a:	82 81       	ldd	r24, Z+2	; 0x02
     13c:	93 81       	ldd	r25, Z+3	; 0x03
     13e:	82 1b       	sub	r24, r18
     140:	93 0b       	sbc	r25, r19
     142:	89 30       	cpi	r24, 0x09	; 9
     144:	91 05       	cpc	r25, r1
     146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     148:	bf 01       	movw	r22, r30
     14a:	62 0f       	add	r22, r18
     14c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     14e:	db 01       	movw	r26, r22
     150:	13 96       	adiw	r26, 0x03	; 3
     152:	9c 93       	st	X, r25
     154:	8e 93       	st	-X, r24
     156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     158:	33 83       	std	Z+3, r19	; 0x03
     15a:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     15c:	12 96       	adiw	r26, 0x02	; 2
     15e:	4d 91       	ld	r20, X+
     160:	5c 91       	ld	r21, X
     162:	13 97       	sbiw	r26, 0x03	; 3
     164:	81 e8       	ldi	r24, 0x81	; 129
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xda>
     16a:	cd 01       	movw	r24, r26
     16c:	ec 01       	movw	r28, r24
     16e:	a8 81       	ld	r26, Y
     170:	b9 81       	ldd	r27, Y+1	; 0x01
     172:	12 96       	adiw	r26, 0x02	; 2
     174:	2d 91       	ld	r18, X+
     176:	3c 91       	ld	r19, X
     178:	13 97       	sbiw	r26, 0x03	; 3
     17a:	24 17       	cp	r18, r20
     17c:	35 07       	cpc	r19, r21
     17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xd8>
     180:	eb 01       	movw	r28, r22
     182:	b9 83       	std	Y+1, r27	; 0x01
     184:	a8 83       	st	Y, r26
     186:	dc 01       	movw	r26, r24
     188:	6d 93       	st	X+, r22
     18a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     18c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     190:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     194:	22 81       	ldd	r18, Z+2	; 0x02
     196:	33 81       	ldd	r19, Z+3	; 0x03
     198:	82 1b       	sub	r24, r18
     19a:	93 0b       	sbc	r25, r19
     19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     1a6:	00 e0       	ldi	r16, 0x00	; 0
     1a8:	10 e0       	ldi	r17, 0x00	; 0
     1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <pvPortMalloc+0x124>
     1ac:	00 e0       	ldi	r16, 0x00	; 0
     1ae:	10 e0       	ldi	r17, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <pvPortMalloc+0x124>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     1b6:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     1ba:	c8 01       	movw	r24, r16
     1bc:	df 91       	pop	r29
     1be:	cf 91       	pop	r28
     1c0:	1f 91       	pop	r17
     1c2:	0f 91       	pop	r16
     1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     1c6:	0f 93       	push	r16
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     1ce:	00 97       	sbiw	r24, 0x00	; 0
     1d0:	41 f1       	breq	.+80     	; 0x222 <vPortFree+0x5c>
     1d2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     1d4:	8c 01       	movw	r16, r24
     1d6:	04 50       	subi	r16, 0x04	; 4
     1d8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     1da:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     1de:	f8 01       	movw	r30, r16
     1e0:	42 81       	ldd	r20, Z+2	; 0x02
     1e2:	53 81       	ldd	r21, Z+3	; 0x03
     1e4:	a1 e8       	ldi	r26, 0x81	; 129
     1e6:	b0 e0       	ldi	r27, 0x00	; 0
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <vPortFree+0x26>
     1ea:	df 01       	movw	r26, r30
     1ec:	ed 91       	ld	r30, X+
     1ee:	fc 91       	ld	r31, X
     1f0:	11 97       	sbiw	r26, 0x01	; 1
     1f2:	22 81       	ldd	r18, Z+2	; 0x02
     1f4:	33 81       	ldd	r19, Z+3	; 0x03
     1f6:	24 17       	cp	r18, r20
     1f8:	35 07       	cpc	r19, r21
     1fa:	b8 f3       	brcs	.-18     	; 0x1ea <vPortFree+0x24>
     1fc:	24 97       	sbiw	r28, 0x04	; 4
     1fe:	f9 83       	std	Y+1, r31	; 0x01
     200:	e8 83       	st	Y, r30
     202:	0d 93       	st	X+, r16
     204:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     206:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     20a:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     20e:	8a 81       	ldd	r24, Y+2	; 0x02
     210:	9b 81       	ldd	r25, Y+3	; 0x03
     212:	82 0f       	add	r24, r18
     214:	93 1f       	adc	r25, r19
     216:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     21e:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
	}
}
     222:	df 91       	pop	r29
     224:	cf 91       	pop	r28
     226:	1f 91       	pop	r17
     228:	0f 91       	pop	r16
     22a:	08 95       	ret

0000022c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     22c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     22e:	03 96       	adiw	r24, 0x03	; 3
     230:	92 83       	std	Z+2, r25	; 0x02
     232:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     234:	2f ef       	ldi	r18, 0xFF	; 255
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	34 83       	std	Z+4, r19	; 0x04
     23a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     23c:	96 83       	std	Z+6, r25	; 0x06
     23e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     240:	90 87       	std	Z+8, r25	; 0x08
     242:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     244:	10 82       	st	Z, r1
     246:	08 95       	ret

00000248 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     248:	fc 01       	movw	r30, r24
     24a:	11 86       	std	Z+9, r1	; 0x09
     24c:	10 86       	std	Z+8, r1	; 0x08
     24e:	08 95       	ret

00000250 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     250:	cf 93       	push	r28
     252:	df 93       	push	r29
     254:	9c 01       	movw	r18, r24
     256:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     258:	dc 01       	movw	r26, r24
     25a:	11 96       	adiw	r26, 0x01	; 1
     25c:	cd 91       	ld	r28, X+
     25e:	dc 91       	ld	r29, X
     260:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     262:	d3 83       	std	Z+3, r29	; 0x03
     264:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     266:	8c 81       	ldd	r24, Y+4	; 0x04
     268:	9d 81       	ldd	r25, Y+5	; 0x05
     26a:	95 83       	std	Z+5, r25	; 0x05
     26c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     26e:	8c 81       	ldd	r24, Y+4	; 0x04
     270:	9d 81       	ldd	r25, Y+5	; 0x05
     272:	dc 01       	movw	r26, r24
     274:	13 96       	adiw	r26, 0x03	; 3
     276:	7c 93       	st	X, r23
     278:	6e 93       	st	-X, r22
     27a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     27c:	7d 83       	std	Y+5, r23	; 0x05
     27e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     280:	31 87       	std	Z+9, r19	; 0x09
     282:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     284:	f9 01       	movw	r30, r18
     286:	80 81       	ld	r24, Z
     288:	8f 5f       	subi	r24, 0xFF	; 255
     28a:	80 83       	st	Z, r24
}
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	08 95       	ret

00000292 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     298:	48 81       	ld	r20, Y
     29a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     29c:	4f 3f       	cpi	r20, 0xFF	; 255
     29e:	2f ef       	ldi	r18, 0xFF	; 255
     2a0:	52 07       	cpc	r21, r18
     2a2:	21 f4       	brne	.+8      	; 0x2ac <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2a4:	fc 01       	movw	r30, r24
     2a6:	a7 81       	ldd	r26, Z+7	; 0x07
     2a8:	b0 85       	ldd	r27, Z+8	; 0x08
     2aa:	0d c0       	rjmp	.+26     	; 0x2c6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ac:	dc 01       	movw	r26, r24
     2ae:	13 96       	adiw	r26, 0x03	; 3
     2b0:	01 c0       	rjmp	.+2      	; 0x2b4 <vListInsert+0x22>
     2b2:	df 01       	movw	r26, r30
     2b4:	12 96       	adiw	r26, 0x02	; 2
     2b6:	ed 91       	ld	r30, X+
     2b8:	fc 91       	ld	r31, X
     2ba:	13 97       	sbiw	r26, 0x03	; 3
     2bc:	20 81       	ld	r18, Z
     2be:	31 81       	ldd	r19, Z+1	; 0x01
     2c0:	42 17       	cp	r20, r18
     2c2:	53 07       	cpc	r21, r19
     2c4:	b0 f7       	brcc	.-20     	; 0x2b2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2c6:	12 96       	adiw	r26, 0x02	; 2
     2c8:	ed 91       	ld	r30, X+
     2ca:	fc 91       	ld	r31, X
     2cc:	13 97       	sbiw	r26, 0x03	; 3
     2ce:	fb 83       	std	Y+3, r31	; 0x03
     2d0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2d2:	d5 83       	std	Z+5, r29	; 0x05
     2d4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2d6:	bd 83       	std	Y+5, r27	; 0x05
     2d8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2da:	13 96       	adiw	r26, 0x03	; 3
     2dc:	dc 93       	st	X, r29
     2de:	ce 93       	st	-X, r28
     2e0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2e2:	99 87       	std	Y+9, r25	; 0x09
     2e4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2e6:	fc 01       	movw	r30, r24
     2e8:	20 81       	ld	r18, Z
     2ea:	2f 5f       	subi	r18, 0xFF	; 255
     2ec:	20 83       	st	Z, r18
}
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	08 95       	ret

000002f4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     2fa:	a0 85       	ldd	r26, Z+8	; 0x08
     2fc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     2fe:	c2 81       	ldd	r28, Z+2	; 0x02
     300:	d3 81       	ldd	r29, Z+3	; 0x03
     302:	84 81       	ldd	r24, Z+4	; 0x04
     304:	95 81       	ldd	r25, Z+5	; 0x05
     306:	9d 83       	std	Y+5, r25	; 0x05
     308:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     30a:	c4 81       	ldd	r28, Z+4	; 0x04
     30c:	d5 81       	ldd	r29, Z+5	; 0x05
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	93 81       	ldd	r25, Z+3	; 0x03
     312:	9b 83       	std	Y+3, r25	; 0x03
     314:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     316:	11 96       	adiw	r26, 0x01	; 1
     318:	8d 91       	ld	r24, X+
     31a:	9c 91       	ld	r25, X
     31c:	12 97       	sbiw	r26, 0x02	; 2
     31e:	e8 17       	cp	r30, r24
     320:	f9 07       	cpc	r31, r25
     322:	31 f4       	brne	.+12     	; 0x330 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     324:	84 81       	ldd	r24, Z+4	; 0x04
     326:	95 81       	ldd	r25, Z+5	; 0x05
     328:	12 96       	adiw	r26, 0x02	; 2
     32a:	9c 93       	st	X, r25
     32c:	8e 93       	st	-X, r24
     32e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     330:	11 86       	std	Z+9, r1	; 0x09
     332:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     334:	8c 91       	ld	r24, X
     336:	81 50       	subi	r24, 0x01	; 1
     338:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     33a:	df 91       	pop	r29
     33c:	cf 91       	pop	r28
     33e:	08 95       	ret

00000340 <vButtonTask>:

	while(1);
}
#define GET_BIT(var,bit)	((var>>bit)&1)

void vButtonTask(void *p){
     340:	cf 93       	push	r28
     342:	df 93       	push	r29
     344:	1f 92       	push	r1
     346:	cd b7       	in	r28, 0x3d	; 61
     348:	de b7       	in	r29, 0x3e	; 62
	
	DDRB&=~(1<<0); 
     34a:	b8 98       	cbi	0x17, 0	; 23
	DDRC|=(1<<7);
     34c:	a7 9a       	sbi	0x14, 7	; 20
	char data=0;
     34e:	19 82       	std	Y+1, r1	; 0x01
	while(1){
	data=GET_BIT(PINB,0);
     350:	86 b3       	in	r24, 0x16	; 22
     352:	81 70       	andi	r24, 0x01	; 1
     354:	89 83       	std	Y+1, r24	; 0x01
	if(data==1){
     356:	81 30       	cpi	r24, 0x01	; 1
     358:	99 f4       	brne	.+38     	; 0x380 <vButtonTask+0x40>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     35a:	8f e4       	ldi	r24, 0x4F	; 79
     35c:	93 ec       	ldi	r25, 0xC3	; 195
     35e:	01 97       	sbiw	r24, 0x01	; 1
     360:	f1 f7       	brne	.-4      	; 0x35e <vButtonTask+0x1e>
     362:	00 c0       	rjmp	.+0      	; 0x364 <vButtonTask+0x24>
     364:	00 00       	nop
		_delay_ms(25);//debounce time
		//queue send
			xQueueSendToBack(button_queue,&data,100/portTICK_PERIOD_MS);
     366:	20 e0       	ldi	r18, 0x00	; 0
     368:	44 e6       	ldi	r20, 0x64	; 100
     36a:	50 e0       	ldi	r21, 0x00	; 0
     36c:	be 01       	movw	r22, r28
     36e:	6f 5f       	subi	r22, 0xFF	; 255
     370:	7f 4f       	sbci	r23, 0xFF	; 255
     372:	80 91 dc 04 	lds	r24, 0x04DC	; 0x8004dc <button_queue>
     376:	90 91 dd 04 	lds	r25, 0x04DD	; 0x8004dd <button_queue+0x1>
     37a:	0e 94 a3 04 	call	0x946	; 0x946 <xQueueGenericSend>
     37e:	0c c0       	rjmp	.+24     	; 0x398 <vButtonTask+0x58>
		
	}//
	else{
	xQueueSendToBack(button_queue,&data,100/portTICK_PERIOD_MS);
     380:	20 e0       	ldi	r18, 0x00	; 0
     382:	44 e6       	ldi	r20, 0x64	; 100
     384:	50 e0       	ldi	r21, 0x00	; 0
     386:	be 01       	movw	r22, r28
     388:	6f 5f       	subi	r22, 0xFF	; 255
     38a:	7f 4f       	sbci	r23, 0xFF	; 255
     38c:	80 91 dc 04 	lds	r24, 0x04DC	; 0x8004dc <button_queue>
     390:	90 91 dd 04 	lds	r25, 0x04DD	; 0x8004dd <button_queue+0x1>
     394:	0e 94 a3 04 	call	0x946	; 0x946 <xQueueGenericSend>

	}
	vTaskDelay(100/portTICK_PERIOD_MS);
     398:	84 e6       	ldi	r24, 0x64	; 100
     39a:	90 e0       	ldi	r25, 0x00	; 0
     39c:	0e 94 02 09 	call	0x1204	; 0x1204 <vTaskDelay>
 }//while
     3a0:	d7 cf       	rjmp	.-82     	; 0x350 <vButtonTask+0x10>

000003a2 <vLEDTask>:
	
}//function

//continous , periodic and sparodic
void vLEDTask(void *p){
     3a2:	cf 93       	push	r28
     3a4:	df 93       	push	r29
     3a6:	1f 92       	push	r1
     3a8:	cd b7       	in	r28, 0x3d	; 61
     3aa:	de b7       	in	r29, 0x3e	; 62
	
	DDRC|=(1<<7);
     3ac:	a7 9a       	sbi	0x14, 7	; 20
	char value;
	
	while(1){
		//queue send
 xQueueReceive(button_queue,&value,100/portTICK_PERIOD_MS);//blocking | non-blocking
     3ae:	20 e0       	ldi	r18, 0x00	; 0
     3b0:	44 e6       	ldi	r20, 0x64	; 100
     3b2:	50 e0       	ldi	r21, 0x00	; 0
     3b4:	be 01       	movw	r22, r28
     3b6:	6f 5f       	subi	r22, 0xFF	; 255
     3b8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ba:	80 91 dc 04 	lds	r24, 0x04DC	; 0x8004dc <button_queue>
     3be:	90 91 dd 04 	lds	r25, 0x04DD	; 0x8004dd <button_queue+0x1>
     3c2:	0e 94 44 05 	call	0xa88	; 0xa88 <xQueueGenericReceive>
		if(value==1){
     3c6:	89 81       	ldd	r24, Y+1	; 0x01
     3c8:	81 30       	cpi	r24, 0x01	; 1
     3ca:	71 f4       	brne	.+28     	; 0x3e8 <vLEDTask+0x46>
			PORTC^=(1<<7);
     3cc:	85 b3       	in	r24, 0x15	; 21
     3ce:	80 58       	subi	r24, 0x80	; 128
     3d0:	85 bb       	out	0x15, r24	; 21
     3d2:	8f e1       	ldi	r24, 0x1F	; 31
     3d4:	9e e4       	ldi	r25, 0x4E	; 78
     3d6:	01 97       	sbiw	r24, 0x01	; 1
     3d8:	f1 f7       	brne	.-4      	; 0x3d6 <vLEDTask+0x34>
     3da:	00 c0       	rjmp	.+0      	; 0x3dc <vLEDTask+0x3a>
     3dc:	00 00       	nop
			_delay_ms(10);
			vTaskDelay(500/portTICK_PERIOD_MS);
     3de:	84 ef       	ldi	r24, 0xF4	; 244
     3e0:	91 e0       	ldi	r25, 0x01	; 1
     3e2:	0e 94 02 09 	call	0x1204	; 0x1204 <vTaskDelay>
     3e6:	e3 cf       	rjmp	.-58     	; 0x3ae <vLEDTask+0xc>

		}//if
		else{
			PORTC&=~(1<<7);
     3e8:	af 98       	cbi	0x15, 7	; 21
     3ea:	e1 cf       	rjmp	.-62     	; 0x3ae <vLEDTask+0xc>

000003ec <main>:
	/*LCD_Initialization();
	LCD_Write_String("Hello");
	LCD_Queue = xQueueCreate(10,sizeof(char)); //10 bytes size 
	CheckPasswordSemaphore = xSemaphoreCreateBinary();
	*/
		button_queue = xQueueCreate(5,sizeof(char));
     3ec:	40 e0       	ldi	r20, 0x00	; 0
     3ee:	61 e0       	ldi	r22, 0x01	; 1
     3f0:	85 e0       	ldi	r24, 0x05	; 5
     3f2:	0e 94 76 04 	call	0x8ec	; 0x8ec <xQueueGenericCreate>
     3f6:	90 93 dd 04 	sts	0x04DD, r25	; 0x8004dd <button_queue+0x1>
     3fa:	80 93 dc 04 	sts	0x04DC, r24	; 0x8004dc <button_queue>

	xTaskCreate(vButtonTask,"Button_Task",300,NULL,1,NULL);
     3fe:	e1 2c       	mov	r14, r1
     400:	f1 2c       	mov	r15, r1
     402:	01 e0       	ldi	r16, 0x01	; 1
     404:	20 e0       	ldi	r18, 0x00	; 0
     406:	30 e0       	ldi	r19, 0x00	; 0
     408:	4c e2       	ldi	r20, 0x2C	; 44
     40a:	51 e0       	ldi	r21, 0x01	; 1
     40c:	62 e6       	ldi	r22, 0x62	; 98
     40e:	70 e0       	ldi	r23, 0x00	; 0
     410:	80 ea       	ldi	r24, 0xA0	; 160
     412:	91 e0       	ldi	r25, 0x01	; 1
     414:	0e 94 87 06 	call	0xd0e	; 0xd0e <xTaskCreate>
	xTaskCreate(vLEDTask,"LED_Task",300,NULL,1,NULL);
     418:	20 e0       	ldi	r18, 0x00	; 0
     41a:	30 e0       	ldi	r19, 0x00	; 0
     41c:	4c e2       	ldi	r20, 0x2C	; 44
     41e:	51 e0       	ldi	r21, 0x01	; 1
     420:	6e e6       	ldi	r22, 0x6E	; 110
     422:	70 e0       	ldi	r23, 0x00	; 0
     424:	81 ed       	ldi	r24, 0xD1	; 209
     426:	91 e0       	ldi	r25, 0x01	; 1
     428:	0e 94 87 06 	call	0xd0e	; 0xd0e <xTaskCreate>
	xTaskCreate( vTask_LCD,"LCD",200,NULL, 1, NULL );
	xTaskCreate( vTask_KeyPad, "Keypad",200,NULL, 2, NULL );
	xTaskCreate( vTask_Password_Check, "check",200,NULL, 3, NULL );
	*/

		DDRC|=(1<<7);
     42c:	a7 9a       	sbi	0x14, 7	; 20

	//PORTC|=(1<<7);
	vTaskStartScheduler();
     42e:	0e 94 98 07 	call	0xf30	; 0xf30 <vTaskStartScheduler>
     432:	ff cf       	rjmp	.-2      	; 0x432 <__EEPROM_REGION_LENGTH__+0x32>

00000434 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     434:	31 e1       	ldi	r19, 0x11	; 17
     436:	fc 01       	movw	r30, r24
     438:	30 83       	st	Z, r19
     43a:	31 97       	sbiw	r30, 0x01	; 1
     43c:	22 e2       	ldi	r18, 0x22	; 34
     43e:	20 83       	st	Z, r18
     440:	31 97       	sbiw	r30, 0x01	; 1
     442:	a3 e3       	ldi	r26, 0x33	; 51
     444:	a0 83       	st	Z, r26
     446:	31 97       	sbiw	r30, 0x01	; 1
     448:	60 83       	st	Z, r22
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	70 83       	st	Z, r23
     44e:	31 97       	sbiw	r30, 0x01	; 1
     450:	10 82       	st	Z, r1
     452:	31 97       	sbiw	r30, 0x01	; 1
     454:	60 e8       	ldi	r22, 0x80	; 128
     456:	60 83       	st	Z, r22
     458:	31 97       	sbiw	r30, 0x01	; 1
     45a:	10 82       	st	Z, r1
     45c:	31 97       	sbiw	r30, 0x01	; 1
     45e:	62 e0       	ldi	r22, 0x02	; 2
     460:	60 83       	st	Z, r22
     462:	31 97       	sbiw	r30, 0x01	; 1
     464:	63 e0       	ldi	r22, 0x03	; 3
     466:	60 83       	st	Z, r22
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	64 e0       	ldi	r22, 0x04	; 4
     46c:	60 83       	st	Z, r22
     46e:	31 97       	sbiw	r30, 0x01	; 1
     470:	65 e0       	ldi	r22, 0x05	; 5
     472:	60 83       	st	Z, r22
     474:	31 97       	sbiw	r30, 0x01	; 1
     476:	66 e0       	ldi	r22, 0x06	; 6
     478:	60 83       	st	Z, r22
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	67 e0       	ldi	r22, 0x07	; 7
     47e:	60 83       	st	Z, r22
     480:	31 97       	sbiw	r30, 0x01	; 1
     482:	68 e0       	ldi	r22, 0x08	; 8
     484:	60 83       	st	Z, r22
     486:	31 97       	sbiw	r30, 0x01	; 1
     488:	69 e0       	ldi	r22, 0x09	; 9
     48a:	60 83       	st	Z, r22
     48c:	31 97       	sbiw	r30, 0x01	; 1
     48e:	60 e1       	ldi	r22, 0x10	; 16
     490:	60 83       	st	Z, r22
     492:	31 97       	sbiw	r30, 0x01	; 1
     494:	30 83       	st	Z, r19
     496:	31 97       	sbiw	r30, 0x01	; 1
     498:	32 e1       	ldi	r19, 0x12	; 18
     49a:	30 83       	st	Z, r19
     49c:	31 97       	sbiw	r30, 0x01	; 1
     49e:	33 e1       	ldi	r19, 0x13	; 19
     4a0:	30 83       	st	Z, r19
     4a2:	31 97       	sbiw	r30, 0x01	; 1
     4a4:	34 e1       	ldi	r19, 0x14	; 20
     4a6:	30 83       	st	Z, r19
     4a8:	31 97       	sbiw	r30, 0x01	; 1
     4aa:	35 e1       	ldi	r19, 0x15	; 21
     4ac:	30 83       	st	Z, r19
     4ae:	31 97       	sbiw	r30, 0x01	; 1
     4b0:	36 e1       	ldi	r19, 0x16	; 22
     4b2:	30 83       	st	Z, r19
     4b4:	31 97       	sbiw	r30, 0x01	; 1
     4b6:	37 e1       	ldi	r19, 0x17	; 23
     4b8:	30 83       	st	Z, r19
     4ba:	31 97       	sbiw	r30, 0x01	; 1
     4bc:	38 e1       	ldi	r19, 0x18	; 24
     4be:	30 83       	st	Z, r19
     4c0:	31 97       	sbiw	r30, 0x01	; 1
     4c2:	39 e1       	ldi	r19, 0x19	; 25
     4c4:	30 83       	st	Z, r19
     4c6:	31 97       	sbiw	r30, 0x01	; 1
     4c8:	30 e2       	ldi	r19, 0x20	; 32
     4ca:	30 83       	st	Z, r19
     4cc:	31 97       	sbiw	r30, 0x01	; 1
     4ce:	31 e2       	ldi	r19, 0x21	; 33
     4d0:	30 83       	st	Z, r19
     4d2:	31 97       	sbiw	r30, 0x01	; 1
     4d4:	20 83       	st	Z, r18
     4d6:	31 97       	sbiw	r30, 0x01	; 1
     4d8:	23 e2       	ldi	r18, 0x23	; 35
     4da:	20 83       	st	Z, r18
     4dc:	31 97       	sbiw	r30, 0x01	; 1
     4de:	40 83       	st	Z, r20
     4e0:	31 97       	sbiw	r30, 0x01	; 1
     4e2:	50 83       	st	Z, r21
     4e4:	31 97       	sbiw	r30, 0x01	; 1
     4e6:	26 e2       	ldi	r18, 0x26	; 38
     4e8:	20 83       	st	Z, r18
     4ea:	31 97       	sbiw	r30, 0x01	; 1
     4ec:	27 e2       	ldi	r18, 0x27	; 39
     4ee:	20 83       	st	Z, r18
     4f0:	31 97       	sbiw	r30, 0x01	; 1
     4f2:	28 e2       	ldi	r18, 0x28	; 40
     4f4:	20 83       	st	Z, r18
     4f6:	31 97       	sbiw	r30, 0x01	; 1
     4f8:	29 e2       	ldi	r18, 0x29	; 41
     4fa:	20 83       	st	Z, r18
     4fc:	31 97       	sbiw	r30, 0x01	; 1
     4fe:	20 e3       	ldi	r18, 0x30	; 48
     500:	20 83       	st	Z, r18
     502:	31 97       	sbiw	r30, 0x01	; 1
     504:	21 e3       	ldi	r18, 0x31	; 49
     506:	20 83       	st	Z, r18
     508:	86 97       	sbiw	r24, 0x26	; 38
     50a:	08 95       	ret

0000050c <xPortStartScheduler>:
     50c:	1b bc       	out	0x2b, r1	; 43
     50e:	8c e7       	ldi	r24, 0x7C	; 124
     510:	8a bd       	out	0x2a, r24	; 42
     512:	8b e0       	ldi	r24, 0x0B	; 11
     514:	8e bd       	out	0x2e, r24	; 46
     516:	89 b7       	in	r24, 0x39	; 57
     518:	80 61       	ori	r24, 0x10	; 16
     51a:	89 bf       	out	0x39, r24	; 57
     51c:	a0 91 da 04 	lds	r26, 0x04DA	; 0x8004da <pxCurrentTCB>
     520:	b0 91 db 04 	lds	r27, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     524:	cd 91       	ld	r28, X+
     526:	cd bf       	out	0x3d, r28	; 61
     528:	dd 91       	ld	r29, X+
     52a:	de bf       	out	0x3e, r29	; 62
     52c:	ff 91       	pop	r31
     52e:	ef 91       	pop	r30
     530:	df 91       	pop	r29
     532:	cf 91       	pop	r28
     534:	bf 91       	pop	r27
     536:	af 91       	pop	r26
     538:	9f 91       	pop	r25
     53a:	8f 91       	pop	r24
     53c:	7f 91       	pop	r23
     53e:	6f 91       	pop	r22
     540:	5f 91       	pop	r21
     542:	4f 91       	pop	r20
     544:	3f 91       	pop	r19
     546:	2f 91       	pop	r18
     548:	1f 91       	pop	r17
     54a:	0f 91       	pop	r16
     54c:	ff 90       	pop	r15
     54e:	ef 90       	pop	r14
     550:	df 90       	pop	r13
     552:	cf 90       	pop	r12
     554:	bf 90       	pop	r11
     556:	af 90       	pop	r10
     558:	9f 90       	pop	r9
     55a:	8f 90       	pop	r8
     55c:	7f 90       	pop	r7
     55e:	6f 90       	pop	r6
     560:	5f 90       	pop	r5
     562:	4f 90       	pop	r4
     564:	3f 90       	pop	r3
     566:	2f 90       	pop	r2
     568:	1f 90       	pop	r1
     56a:	0f 90       	pop	r0
     56c:	0f be       	out	0x3f, r0	; 63
     56e:	0f 90       	pop	r0
     570:	08 95       	ret
     572:	81 e0       	ldi	r24, 0x01	; 1
     574:	08 95       	ret

00000576 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     576:	0f 92       	push	r0
     578:	0f b6       	in	r0, 0x3f	; 63
     57a:	f8 94       	cli
     57c:	0f 92       	push	r0
     57e:	1f 92       	push	r1
     580:	11 24       	eor	r1, r1
     582:	2f 92       	push	r2
     584:	3f 92       	push	r3
     586:	4f 92       	push	r4
     588:	5f 92       	push	r5
     58a:	6f 92       	push	r6
     58c:	7f 92       	push	r7
     58e:	8f 92       	push	r8
     590:	9f 92       	push	r9
     592:	af 92       	push	r10
     594:	bf 92       	push	r11
     596:	cf 92       	push	r12
     598:	df 92       	push	r13
     59a:	ef 92       	push	r14
     59c:	ff 92       	push	r15
     59e:	0f 93       	push	r16
     5a0:	1f 93       	push	r17
     5a2:	2f 93       	push	r18
     5a4:	3f 93       	push	r19
     5a6:	4f 93       	push	r20
     5a8:	5f 93       	push	r21
     5aa:	6f 93       	push	r22
     5ac:	7f 93       	push	r23
     5ae:	8f 93       	push	r24
     5b0:	9f 93       	push	r25
     5b2:	af 93       	push	r26
     5b4:	bf 93       	push	r27
     5b6:	cf 93       	push	r28
     5b8:	df 93       	push	r29
     5ba:	ef 93       	push	r30
     5bc:	ff 93       	push	r31
     5be:	a0 91 da 04 	lds	r26, 0x04DA	; 0x8004da <pxCurrentTCB>
     5c2:	b0 91 db 04 	lds	r27, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     5c6:	0d b6       	in	r0, 0x3d	; 61
     5c8:	0d 92       	st	X+, r0
     5ca:	0e b6       	in	r0, 0x3e	; 62
     5cc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     5ce:	0e 94 53 09 	call	0x12a6	; 0x12a6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5d2:	a0 91 da 04 	lds	r26, 0x04DA	; 0x8004da <pxCurrentTCB>
     5d6:	b0 91 db 04 	lds	r27, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     5da:	cd 91       	ld	r28, X+
     5dc:	cd bf       	out	0x3d, r28	; 61
     5de:	dd 91       	ld	r29, X+
     5e0:	de bf       	out	0x3e, r29	; 62
     5e2:	ff 91       	pop	r31
     5e4:	ef 91       	pop	r30
     5e6:	df 91       	pop	r29
     5e8:	cf 91       	pop	r28
     5ea:	bf 91       	pop	r27
     5ec:	af 91       	pop	r26
     5ee:	9f 91       	pop	r25
     5f0:	8f 91       	pop	r24
     5f2:	7f 91       	pop	r23
     5f4:	6f 91       	pop	r22
     5f6:	5f 91       	pop	r21
     5f8:	4f 91       	pop	r20
     5fa:	3f 91       	pop	r19
     5fc:	2f 91       	pop	r18
     5fe:	1f 91       	pop	r17
     600:	0f 91       	pop	r16
     602:	ff 90       	pop	r15
     604:	ef 90       	pop	r14
     606:	df 90       	pop	r13
     608:	cf 90       	pop	r12
     60a:	bf 90       	pop	r11
     60c:	af 90       	pop	r10
     60e:	9f 90       	pop	r9
     610:	8f 90       	pop	r8
     612:	7f 90       	pop	r7
     614:	6f 90       	pop	r6
     616:	5f 90       	pop	r5
     618:	4f 90       	pop	r4
     61a:	3f 90       	pop	r3
     61c:	2f 90       	pop	r2
     61e:	1f 90       	pop	r1
     620:	0f 90       	pop	r0
     622:	0f be       	out	0x3f, r0	; 63
     624:	0f 90       	pop	r0

	asm volatile ( "ret" );
     626:	08 95       	ret

00000628 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     628:	0f 92       	push	r0
     62a:	0f b6       	in	r0, 0x3f	; 63
     62c:	f8 94       	cli
     62e:	0f 92       	push	r0
     630:	1f 92       	push	r1
     632:	11 24       	eor	r1, r1
     634:	2f 92       	push	r2
     636:	3f 92       	push	r3
     638:	4f 92       	push	r4
     63a:	5f 92       	push	r5
     63c:	6f 92       	push	r6
     63e:	7f 92       	push	r7
     640:	8f 92       	push	r8
     642:	9f 92       	push	r9
     644:	af 92       	push	r10
     646:	bf 92       	push	r11
     648:	cf 92       	push	r12
     64a:	df 92       	push	r13
     64c:	ef 92       	push	r14
     64e:	ff 92       	push	r15
     650:	0f 93       	push	r16
     652:	1f 93       	push	r17
     654:	2f 93       	push	r18
     656:	3f 93       	push	r19
     658:	4f 93       	push	r20
     65a:	5f 93       	push	r21
     65c:	6f 93       	push	r22
     65e:	7f 93       	push	r23
     660:	8f 93       	push	r24
     662:	9f 93       	push	r25
     664:	af 93       	push	r26
     666:	bf 93       	push	r27
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
     66c:	ef 93       	push	r30
     66e:	ff 93       	push	r31
     670:	a0 91 da 04 	lds	r26, 0x04DA	; 0x8004da <pxCurrentTCB>
     674:	b0 91 db 04 	lds	r27, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     678:	0d b6       	in	r0, 0x3d	; 61
     67a:	0d 92       	st	X+, r0
     67c:	0e b6       	in	r0, 0x3e	; 62
     67e:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     680:	0e 94 c8 07 	call	0xf90	; 0xf90 <xTaskIncrementTick>
     684:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     686:	0e 94 53 09 	call	0x12a6	; 0x12a6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     68a:	a0 91 da 04 	lds	r26, 0x04DA	; 0x8004da <pxCurrentTCB>
     68e:	b0 91 db 04 	lds	r27, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     692:	cd 91       	ld	r28, X+
     694:	cd bf       	out	0x3d, r28	; 61
     696:	dd 91       	ld	r29, X+
     698:	de bf       	out	0x3e, r29	; 62
     69a:	ff 91       	pop	r31
     69c:	ef 91       	pop	r30
     69e:	df 91       	pop	r29
     6a0:	cf 91       	pop	r28
     6a2:	bf 91       	pop	r27
     6a4:	af 91       	pop	r26
     6a6:	9f 91       	pop	r25
     6a8:	8f 91       	pop	r24
     6aa:	7f 91       	pop	r23
     6ac:	6f 91       	pop	r22
     6ae:	5f 91       	pop	r21
     6b0:	4f 91       	pop	r20
     6b2:	3f 91       	pop	r19
     6b4:	2f 91       	pop	r18
     6b6:	1f 91       	pop	r17
     6b8:	0f 91       	pop	r16
     6ba:	ff 90       	pop	r15
     6bc:	ef 90       	pop	r14
     6be:	df 90       	pop	r13
     6c0:	cf 90       	pop	r12
     6c2:	bf 90       	pop	r11
     6c4:	af 90       	pop	r10
     6c6:	9f 90       	pop	r9
     6c8:	8f 90       	pop	r8
     6ca:	7f 90       	pop	r7
     6cc:	6f 90       	pop	r6
     6ce:	5f 90       	pop	r5
     6d0:	4f 90       	pop	r4
     6d2:	3f 90       	pop	r3
     6d4:	2f 90       	pop	r2
     6d6:	1f 90       	pop	r1
     6d8:	0f 90       	pop	r0
     6da:	0f be       	out	0x3f, r0	; 63
     6dc:	0f 90       	pop	r0

	asm volatile ( "ret" );
     6de:	08 95       	ret

000006e0 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     6e0:	0e 94 14 03 	call	0x628	; 0x628 <vPortYieldFromTick>
		asm volatile ( "reti" );
     6e4:	18 95       	reti

000006e6 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     6e6:	0f 93       	push	r16
     6e8:	1f 93       	push	r17
     6ea:	cf 93       	push	r28
     6ec:	df 93       	push	r29
     6ee:	ec 01       	movw	r28, r24
     6f0:	04 2f       	mov	r16, r20
     6f2:	1a 8d       	ldd	r17, Y+26	; 0x1a
     6f4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     6f6:	41 11       	cpse	r20, r1
     6f8:	0c c0       	rjmp	.+24     	; 0x712 <prvCopyDataToQueue+0x2c>
     6fa:	88 81       	ld	r24, Y
     6fc:	99 81       	ldd	r25, Y+1	; 0x01
     6fe:	89 2b       	or	r24, r25
     700:	09 f0       	breq	.+2      	; 0x704 <prvCopyDataToQueue+0x1e>
     702:	42 c0       	rjmp	.+132    	; 0x788 <prvCopyDataToQueue+0xa2>
     704:	8a 81       	ldd	r24, Y+2	; 0x02
     706:	9b 81       	ldd	r25, Y+3	; 0x03
     708:	0e 94 bd 0a 	call	0x157a	; 0x157a <xTaskPriorityDisinherit>
     70c:	1b 82       	std	Y+3, r1	; 0x03
     70e:	1a 82       	std	Y+2, r1	; 0x02
     710:	42 c0       	rjmp	.+132    	; 0x796 <prvCopyDataToQueue+0xb0>
     712:	01 11       	cpse	r16, r1
     714:	17 c0       	rjmp	.+46     	; 0x744 <prvCopyDataToQueue+0x5e>
     716:	50 e0       	ldi	r21, 0x00	; 0
     718:	8c 81       	ldd	r24, Y+4	; 0x04
     71a:	9d 81       	ldd	r25, Y+5	; 0x05
     71c:	0e 94 0f 0b 	call	0x161e	; 0x161e <memcpy>
     720:	2c 8d       	ldd	r18, Y+28	; 0x1c
     722:	8c 81       	ldd	r24, Y+4	; 0x04
     724:	9d 81       	ldd	r25, Y+5	; 0x05
     726:	82 0f       	add	r24, r18
     728:	91 1d       	adc	r25, r1
     72a:	9d 83       	std	Y+5, r25	; 0x05
     72c:	8c 83       	std	Y+4, r24	; 0x04
     72e:	2a 81       	ldd	r18, Y+2	; 0x02
     730:	3b 81       	ldd	r19, Y+3	; 0x03
     732:	82 17       	cp	r24, r18
     734:	93 07       	cpc	r25, r19
     736:	50 f1       	brcs	.+84     	; 0x78c <prvCopyDataToQueue+0xa6>
     738:	88 81       	ld	r24, Y
     73a:	99 81       	ldd	r25, Y+1	; 0x01
     73c:	9d 83       	std	Y+5, r25	; 0x05
     73e:	8c 83       	std	Y+4, r24	; 0x04
     740:	80 e0       	ldi	r24, 0x00	; 0
     742:	29 c0       	rjmp	.+82     	; 0x796 <prvCopyDataToQueue+0xb0>
     744:	50 e0       	ldi	r21, 0x00	; 0
     746:	8e 81       	ldd	r24, Y+6	; 0x06
     748:	9f 81       	ldd	r25, Y+7	; 0x07
     74a:	0e 94 0f 0b 	call	0x161e	; 0x161e <memcpy>
     74e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     750:	90 e0       	ldi	r25, 0x00	; 0
     752:	91 95       	neg	r25
     754:	81 95       	neg	r24
     756:	91 09       	sbc	r25, r1
     758:	2e 81       	ldd	r18, Y+6	; 0x06
     75a:	3f 81       	ldd	r19, Y+7	; 0x07
     75c:	28 0f       	add	r18, r24
     75e:	39 1f       	adc	r19, r25
     760:	3f 83       	std	Y+7, r19	; 0x07
     762:	2e 83       	std	Y+6, r18	; 0x06
     764:	48 81       	ld	r20, Y
     766:	59 81       	ldd	r21, Y+1	; 0x01
     768:	24 17       	cp	r18, r20
     76a:	35 07       	cpc	r19, r21
     76c:	30 f4       	brcc	.+12     	; 0x77a <prvCopyDataToQueue+0x94>
     76e:	2a 81       	ldd	r18, Y+2	; 0x02
     770:	3b 81       	ldd	r19, Y+3	; 0x03
     772:	82 0f       	add	r24, r18
     774:	93 1f       	adc	r25, r19
     776:	9f 83       	std	Y+7, r25	; 0x07
     778:	8e 83       	std	Y+6, r24	; 0x06
     77a:	02 30       	cpi	r16, 0x02	; 2
     77c:	49 f4       	brne	.+18     	; 0x790 <prvCopyDataToQueue+0xaa>
     77e:	11 23       	and	r17, r17
     780:	49 f0       	breq	.+18     	; 0x794 <prvCopyDataToQueue+0xae>
     782:	11 50       	subi	r17, 0x01	; 1
     784:	80 e0       	ldi	r24, 0x00	; 0
     786:	07 c0       	rjmp	.+14     	; 0x796 <prvCopyDataToQueue+0xb0>
     788:	80 e0       	ldi	r24, 0x00	; 0
     78a:	05 c0       	rjmp	.+10     	; 0x796 <prvCopyDataToQueue+0xb0>
     78c:	80 e0       	ldi	r24, 0x00	; 0
     78e:	03 c0       	rjmp	.+6      	; 0x796 <prvCopyDataToQueue+0xb0>
     790:	80 e0       	ldi	r24, 0x00	; 0
     792:	01 c0       	rjmp	.+2      	; 0x796 <prvCopyDataToQueue+0xb0>
     794:	80 e0       	ldi	r24, 0x00	; 0
     796:	1f 5f       	subi	r17, 0xFF	; 255
     798:	1a 8f       	std	Y+26, r17	; 0x1a
     79a:	df 91       	pop	r29
     79c:	cf 91       	pop	r28
     79e:	1f 91       	pop	r17
     7a0:	0f 91       	pop	r16
     7a2:	08 95       	ret

000007a4 <prvCopyDataFromQueue>:
     7a4:	fc 01       	movw	r30, r24
     7a6:	44 8d       	ldd	r20, Z+28	; 0x1c
     7a8:	44 23       	and	r20, r20
     7aa:	a9 f0       	breq	.+42     	; 0x7d6 <prvCopyDataFromQueue+0x32>
     7ac:	50 e0       	ldi	r21, 0x00	; 0
     7ae:	26 81       	ldd	r18, Z+6	; 0x06
     7b0:	37 81       	ldd	r19, Z+7	; 0x07
     7b2:	24 0f       	add	r18, r20
     7b4:	35 1f       	adc	r19, r21
     7b6:	37 83       	std	Z+7, r19	; 0x07
     7b8:	26 83       	std	Z+6, r18	; 0x06
     7ba:	82 81       	ldd	r24, Z+2	; 0x02
     7bc:	93 81       	ldd	r25, Z+3	; 0x03
     7be:	28 17       	cp	r18, r24
     7c0:	39 07       	cpc	r19, r25
     7c2:	20 f0       	brcs	.+8      	; 0x7cc <prvCopyDataFromQueue+0x28>
     7c4:	80 81       	ld	r24, Z
     7c6:	91 81       	ldd	r25, Z+1	; 0x01
     7c8:	97 83       	std	Z+7, r25	; 0x07
     7ca:	86 83       	std	Z+6, r24	; 0x06
     7cc:	cb 01       	movw	r24, r22
     7ce:	66 81       	ldd	r22, Z+6	; 0x06
     7d0:	77 81       	ldd	r23, Z+7	; 0x07
     7d2:	0e 94 0f 0b 	call	0x161e	; 0x161e <memcpy>
     7d6:	08 95       	ret

000007d8 <prvUnlockQueue>:
     7d8:	ef 92       	push	r14
     7da:	ff 92       	push	r15
     7dc:	0f 93       	push	r16
     7de:	1f 93       	push	r17
     7e0:	cf 93       	push	r28
     7e2:	8c 01       	movw	r16, r24
     7e4:	0f b6       	in	r0, 0x3f	; 63
     7e6:	f8 94       	cli
     7e8:	0f 92       	push	r0
     7ea:	fc 01       	movw	r30, r24
     7ec:	c6 8d       	ldd	r28, Z+30	; 0x1e
     7ee:	1c 16       	cp	r1, r28
     7f0:	ac f4       	brge	.+42     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
     7f2:	81 89       	ldd	r24, Z+17	; 0x11
     7f4:	81 11       	cpse	r24, r1
     7f6:	06 c0       	rjmp	.+12     	; 0x804 <__DATA_REGION_LENGTH__+0x4>
     7f8:	11 c0       	rjmp	.+34     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
     7fa:	f8 01       	movw	r30, r16
     7fc:	81 89       	ldd	r24, Z+17	; 0x11
     7fe:	81 11       	cpse	r24, r1
     800:	05 c0       	rjmp	.+10     	; 0x80c <__DATA_REGION_LENGTH__+0xc>
     802:	0c c0       	rjmp	.+24     	; 0x81c <__DATA_REGION_LENGTH__+0x1c>
     804:	78 01       	movw	r14, r16
     806:	f1 e1       	ldi	r31, 0x11	; 17
     808:	ef 0e       	add	r14, r31
     80a:	f1 1c       	adc	r15, r1
     80c:	c7 01       	movw	r24, r14
     80e:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     812:	81 11       	cpse	r24, r1
     814:	0e 94 57 0a 	call	0x14ae	; 0x14ae <vTaskMissedYield>
     818:	c1 50       	subi	r28, 0x01	; 1
     81a:	79 f7       	brne	.-34     	; 0x7fa <prvUnlockQueue+0x22>
     81c:	8f ef       	ldi	r24, 0xFF	; 255
     81e:	f8 01       	movw	r30, r16
     820:	86 8f       	std	Z+30, r24	; 0x1e
     822:	0f 90       	pop	r0
     824:	0f be       	out	0x3f, r0	; 63
     826:	0f b6       	in	r0, 0x3f	; 63
     828:	f8 94       	cli
     82a:	0f 92       	push	r0
     82c:	c5 8d       	ldd	r28, Z+29	; 0x1d
     82e:	1c 16       	cp	r1, r28
     830:	ac f4       	brge	.+42     	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
     832:	80 85       	ldd	r24, Z+8	; 0x08
     834:	81 11       	cpse	r24, r1
     836:	06 c0       	rjmp	.+12     	; 0x844 <__DATA_REGION_LENGTH__+0x44>
     838:	11 c0       	rjmp	.+34     	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
     83a:	f8 01       	movw	r30, r16
     83c:	80 85       	ldd	r24, Z+8	; 0x08
     83e:	81 11       	cpse	r24, r1
     840:	05 c0       	rjmp	.+10     	; 0x84c <__DATA_REGION_LENGTH__+0x4c>
     842:	0c c0       	rjmp	.+24     	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
     844:	78 01       	movw	r14, r16
     846:	f8 e0       	ldi	r31, 0x08	; 8
     848:	ef 0e       	add	r14, r31
     84a:	f1 1c       	adc	r15, r1
     84c:	c7 01       	movw	r24, r14
     84e:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     852:	81 11       	cpse	r24, r1
     854:	0e 94 57 0a 	call	0x14ae	; 0x14ae <vTaskMissedYield>
     858:	c1 50       	subi	r28, 0x01	; 1
     85a:	79 f7       	brne	.-34     	; 0x83a <__DATA_REGION_LENGTH__+0x3a>
     85c:	8f ef       	ldi	r24, 0xFF	; 255
     85e:	f8 01       	movw	r30, r16
     860:	85 8f       	std	Z+29, r24	; 0x1d
     862:	0f 90       	pop	r0
     864:	0f be       	out	0x3f, r0	; 63
     866:	cf 91       	pop	r28
     868:	1f 91       	pop	r17
     86a:	0f 91       	pop	r16
     86c:	ff 90       	pop	r15
     86e:	ef 90       	pop	r14
     870:	08 95       	ret

00000872 <xQueueGenericReset>:
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	ec 01       	movw	r28, r24
     878:	0f b6       	in	r0, 0x3f	; 63
     87a:	f8 94       	cli
     87c:	0f 92       	push	r0
     87e:	48 81       	ld	r20, Y
     880:	59 81       	ldd	r21, Y+1	; 0x01
     882:	2c 8d       	ldd	r18, Y+28	; 0x1c
     884:	30 e0       	ldi	r19, 0x00	; 0
     886:	7b 8d       	ldd	r23, Y+27	; 0x1b
     888:	72 9f       	mul	r23, r18
     88a:	c0 01       	movw	r24, r0
     88c:	73 9f       	mul	r23, r19
     88e:	90 0d       	add	r25, r0
     890:	11 24       	eor	r1, r1
     892:	fa 01       	movw	r30, r20
     894:	e8 0f       	add	r30, r24
     896:	f9 1f       	adc	r31, r25
     898:	fb 83       	std	Y+3, r31	; 0x03
     89a:	ea 83       	std	Y+2, r30	; 0x02
     89c:	1a 8e       	std	Y+26, r1	; 0x1a
     89e:	5d 83       	std	Y+5, r21	; 0x05
     8a0:	4c 83       	std	Y+4, r20	; 0x04
     8a2:	82 1b       	sub	r24, r18
     8a4:	93 0b       	sbc	r25, r19
     8a6:	84 0f       	add	r24, r20
     8a8:	95 1f       	adc	r25, r21
     8aa:	9f 83       	std	Y+7, r25	; 0x07
     8ac:	8e 83       	std	Y+6, r24	; 0x06
     8ae:	8f ef       	ldi	r24, 0xFF	; 255
     8b0:	8d 8f       	std	Y+29, r24	; 0x1d
     8b2:	8e 8f       	std	Y+30, r24	; 0x1e
     8b4:	61 11       	cpse	r22, r1
     8b6:	0c c0       	rjmp	.+24     	; 0x8d0 <xQueueGenericReset+0x5e>
     8b8:	88 85       	ldd	r24, Y+8	; 0x08
     8ba:	88 23       	and	r24, r24
     8bc:	89 f0       	breq	.+34     	; 0x8e0 <xQueueGenericReset+0x6e>
     8be:	ce 01       	movw	r24, r28
     8c0:	08 96       	adiw	r24, 0x08	; 8
     8c2:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     8c6:	88 23       	and	r24, r24
     8c8:	59 f0       	breq	.+22     	; 0x8e0 <xQueueGenericReset+0x6e>
     8ca:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
     8ce:	08 c0       	rjmp	.+16     	; 0x8e0 <xQueueGenericReset+0x6e>
     8d0:	ce 01       	movw	r24, r28
     8d2:	08 96       	adiw	r24, 0x08	; 8
     8d4:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     8d8:	ce 01       	movw	r24, r28
     8da:	41 96       	adiw	r24, 0x11	; 17
     8dc:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     8e0:	0f 90       	pop	r0
     8e2:	0f be       	out	0x3f, r0	; 63
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	df 91       	pop	r29
     8e8:	cf 91       	pop	r28
     8ea:	08 95       	ret

000008ec <xQueueGenericCreate>:
     8ec:	0f 93       	push	r16
     8ee:	1f 93       	push	r17
     8f0:	cf 93       	push	r28
     8f2:	df 93       	push	r29
     8f4:	08 2f       	mov	r16, r24
     8f6:	16 2f       	mov	r17, r22
     8f8:	66 23       	and	r22, r22
     8fa:	c1 f0       	breq	.+48     	; 0x92c <xQueueGenericCreate+0x40>
     8fc:	86 9f       	mul	r24, r22
     8fe:	c0 01       	movw	r24, r0
     900:	11 24       	eor	r1, r1
     902:	4f 96       	adiw	r24, 0x1f	; 31
     904:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     908:	ec 01       	movw	r28, r24
     90a:	00 97       	sbiw	r24, 0x00	; 0
     90c:	41 f4       	brne	.+16     	; 0x91e <xQueueGenericCreate+0x32>
     90e:	15 c0       	rjmp	.+42     	; 0x93a <xQueueGenericCreate+0x4e>
     910:	0b 8f       	std	Y+27, r16	; 0x1b
     912:	1c 8f       	std	Y+28, r17	; 0x1c
     914:	61 e0       	ldi	r22, 0x01	; 1
     916:	ce 01       	movw	r24, r28
     918:	0e 94 39 04 	call	0x872	; 0x872 <xQueueGenericReset>
     91c:	0e c0       	rjmp	.+28     	; 0x93a <xQueueGenericCreate+0x4e>
     91e:	4f 96       	adiw	r24, 0x1f	; 31
     920:	99 83       	std	Y+1, r25	; 0x01
     922:	88 83       	st	Y, r24
     924:	f5 cf       	rjmp	.-22     	; 0x910 <xQueueGenericCreate+0x24>
     926:	d9 83       	std	Y+1, r29	; 0x01
     928:	c8 83       	st	Y, r28
     92a:	f2 cf       	rjmp	.-28     	; 0x910 <xQueueGenericCreate+0x24>
     92c:	8f e1       	ldi	r24, 0x1F	; 31
     92e:	90 e0       	ldi	r25, 0x00	; 0
     930:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     934:	ec 01       	movw	r28, r24
     936:	89 2b       	or	r24, r25
     938:	b1 f7       	brne	.-20     	; 0x926 <xQueueGenericCreate+0x3a>
     93a:	ce 01       	movw	r24, r28
     93c:	df 91       	pop	r29
     93e:	cf 91       	pop	r28
     940:	1f 91       	pop	r17
     942:	0f 91       	pop	r16
     944:	08 95       	ret

00000946 <xQueueGenericSend>:
     946:	9f 92       	push	r9
     948:	af 92       	push	r10
     94a:	bf 92       	push	r11
     94c:	cf 92       	push	r12
     94e:	df 92       	push	r13
     950:	ef 92       	push	r14
     952:	ff 92       	push	r15
     954:	0f 93       	push	r16
     956:	1f 93       	push	r17
     958:	cf 93       	push	r28
     95a:	df 93       	push	r29
     95c:	00 d0       	rcall	.+0      	; 0x95e <xQueueGenericSend+0x18>
     95e:	00 d0       	rcall	.+0      	; 0x960 <xQueueGenericSend+0x1a>
     960:	1f 92       	push	r1
     962:	cd b7       	in	r28, 0x3d	; 61
     964:	de b7       	in	r29, 0x3e	; 62
     966:	8c 01       	movw	r16, r24
     968:	6b 01       	movw	r12, r22
     96a:	5d 83       	std	Y+5, r21	; 0x05
     96c:	4c 83       	std	Y+4, r20	; 0x04
     96e:	a2 2e       	mov	r10, r18
     970:	b1 2c       	mov	r11, r1
     972:	99 24       	eor	r9, r9
     974:	93 94       	inc	r9
     976:	7c 01       	movw	r14, r24
     978:	88 e0       	ldi	r24, 0x08	; 8
     97a:	e8 0e       	add	r14, r24
     97c:	f1 1c       	adc	r15, r1
     97e:	0f b6       	in	r0, 0x3f	; 63
     980:	f8 94       	cli
     982:	0f 92       	push	r0
     984:	f8 01       	movw	r30, r16
     986:	92 8d       	ldd	r25, Z+26	; 0x1a
     988:	83 8d       	ldd	r24, Z+27	; 0x1b
     98a:	98 17       	cp	r25, r24
     98c:	18 f0       	brcs	.+6      	; 0x994 <xQueueGenericSend+0x4e>
     98e:	f2 e0       	ldi	r31, 0x02	; 2
     990:	af 12       	cpse	r10, r31
     992:	19 c0       	rjmp	.+50     	; 0x9c6 <xQueueGenericSend+0x80>
     994:	4a 2d       	mov	r20, r10
     996:	b6 01       	movw	r22, r12
     998:	c8 01       	movw	r24, r16
     99a:	0e 94 73 03 	call	0x6e6	; 0x6e6 <prvCopyDataToQueue>
     99e:	f8 01       	movw	r30, r16
     9a0:	91 89       	ldd	r25, Z+17	; 0x11
     9a2:	99 23       	and	r25, r25
     9a4:	49 f0       	breq	.+18     	; 0x9b8 <xQueueGenericSend+0x72>
     9a6:	c8 01       	movw	r24, r16
     9a8:	41 96       	adiw	r24, 0x11	; 17
     9aa:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     9ae:	88 23       	and	r24, r24
     9b0:	31 f0       	breq	.+12     	; 0x9be <xQueueGenericSend+0x78>
     9b2:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
     9b6:	03 c0       	rjmp	.+6      	; 0x9be <xQueueGenericSend+0x78>
     9b8:	81 11       	cpse	r24, r1
     9ba:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
     9be:	0f 90       	pop	r0
     9c0:	0f be       	out	0x3f, r0	; 63
     9c2:	81 e0       	ldi	r24, 0x01	; 1
     9c4:	50 c0       	rjmp	.+160    	; 0xa66 <xQueueGenericSend+0x120>
     9c6:	8c 81       	ldd	r24, Y+4	; 0x04
     9c8:	9d 81       	ldd	r25, Y+5	; 0x05
     9ca:	89 2b       	or	r24, r25
     9cc:	21 f4       	brne	.+8      	; 0x9d6 <xQueueGenericSend+0x90>
     9ce:	0f 90       	pop	r0
     9d0:	0f be       	out	0x3f, r0	; 63
     9d2:	80 e0       	ldi	r24, 0x00	; 0
     9d4:	48 c0       	rjmp	.+144    	; 0xa66 <xQueueGenericSend+0x120>
     9d6:	b1 10       	cpse	r11, r1
     9d8:	05 c0       	rjmp	.+10     	; 0x9e4 <xQueueGenericSend+0x9e>
     9da:	ce 01       	movw	r24, r28
     9dc:	01 96       	adiw	r24, 0x01	; 1
     9de:	0e 94 13 0a 	call	0x1426	; 0x1426 <vTaskSetTimeOutState>
     9e2:	b9 2c       	mov	r11, r9
     9e4:	0f 90       	pop	r0
     9e6:	0f be       	out	0x3f, r0	; 63
     9e8:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
     9ec:	0f b6       	in	r0, 0x3f	; 63
     9ee:	f8 94       	cli
     9f0:	0f 92       	push	r0
     9f2:	f8 01       	movw	r30, r16
     9f4:	85 8d       	ldd	r24, Z+29	; 0x1d
     9f6:	8f 3f       	cpi	r24, 0xFF	; 255
     9f8:	09 f4       	brne	.+2      	; 0x9fc <xQueueGenericSend+0xb6>
     9fa:	15 8e       	std	Z+29, r1	; 0x1d
     9fc:	f8 01       	movw	r30, r16
     9fe:	86 8d       	ldd	r24, Z+30	; 0x1e
     a00:	8f 3f       	cpi	r24, 0xFF	; 255
     a02:	09 f4       	brne	.+2      	; 0xa06 <xQueueGenericSend+0xc0>
     a04:	16 8e       	std	Z+30, r1	; 0x1e
     a06:	0f 90       	pop	r0
     a08:	0f be       	out	0x3f, r0	; 63
     a0a:	be 01       	movw	r22, r28
     a0c:	6c 5f       	subi	r22, 0xFC	; 252
     a0e:	7f 4f       	sbci	r23, 0xFF	; 255
     a10:	ce 01       	movw	r24, r28
     a12:	01 96       	adiw	r24, 0x01	; 1
     a14:	0e 94 1e 0a 	call	0x143c	; 0x143c <xTaskCheckForTimeOut>
     a18:	81 11       	cpse	r24, r1
     a1a:	1f c0       	rjmp	.+62     	; 0xa5a <xQueueGenericSend+0x114>
     a1c:	0f b6       	in	r0, 0x3f	; 63
     a1e:	f8 94       	cli
     a20:	0f 92       	push	r0
     a22:	f8 01       	movw	r30, r16
     a24:	92 8d       	ldd	r25, Z+26	; 0x1a
     a26:	0f 90       	pop	r0
     a28:	0f be       	out	0x3f, r0	; 63
     a2a:	83 8d       	ldd	r24, Z+27	; 0x1b
     a2c:	98 13       	cpse	r25, r24
     a2e:	0f c0       	rjmp	.+30     	; 0xa4e <xQueueGenericSend+0x108>
     a30:	6c 81       	ldd	r22, Y+4	; 0x04
     a32:	7d 81       	ldd	r23, Y+5	; 0x05
     a34:	c7 01       	movw	r24, r14
     a36:	0e 94 b9 09 	call	0x1372	; 0x1372 <vTaskPlaceOnEventList>
     a3a:	c8 01       	movw	r24, r16
     a3c:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <prvUnlockQueue>
     a40:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
     a44:	81 11       	cpse	r24, r1
     a46:	9b cf       	rjmp	.-202    	; 0x97e <xQueueGenericSend+0x38>
     a48:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
     a4c:	98 cf       	rjmp	.-208    	; 0x97e <xQueueGenericSend+0x38>
     a4e:	c8 01       	movw	r24, r16
     a50:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <prvUnlockQueue>
     a54:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
     a58:	92 cf       	rjmp	.-220    	; 0x97e <xQueueGenericSend+0x38>
     a5a:	c8 01       	movw	r24, r16
     a5c:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <prvUnlockQueue>
     a60:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
     a64:	80 e0       	ldi	r24, 0x00	; 0
     a66:	0f 90       	pop	r0
     a68:	0f 90       	pop	r0
     a6a:	0f 90       	pop	r0
     a6c:	0f 90       	pop	r0
     a6e:	0f 90       	pop	r0
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	1f 91       	pop	r17
     a76:	0f 91       	pop	r16
     a78:	ff 90       	pop	r15
     a7a:	ef 90       	pop	r14
     a7c:	df 90       	pop	r13
     a7e:	cf 90       	pop	r12
     a80:	bf 90       	pop	r11
     a82:	af 90       	pop	r10
     a84:	9f 90       	pop	r9
     a86:	08 95       	ret

00000a88 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     a88:	8f 92       	push	r8
     a8a:	9f 92       	push	r9
     a8c:	af 92       	push	r10
     a8e:	bf 92       	push	r11
     a90:	cf 92       	push	r12
     a92:	df 92       	push	r13
     a94:	ef 92       	push	r14
     a96:	ff 92       	push	r15
     a98:	0f 93       	push	r16
     a9a:	1f 93       	push	r17
     a9c:	cf 93       	push	r28
     a9e:	df 93       	push	r29
     aa0:	00 d0       	rcall	.+0      	; 0xaa2 <xQueueGenericReceive+0x1a>
     aa2:	00 d0       	rcall	.+0      	; 0xaa4 <xQueueGenericReceive+0x1c>
     aa4:	1f 92       	push	r1
     aa6:	cd b7       	in	r28, 0x3d	; 61
     aa8:	de b7       	in	r29, 0x3e	; 62
     aaa:	8c 01       	movw	r16, r24
     aac:	5b 01       	movw	r10, r22
     aae:	5d 83       	std	Y+5, r21	; 0x05
     ab0:	4c 83       	std	Y+4, r20	; 0x04
     ab2:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     ab4:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     ab6:	99 24       	eor	r9, r9
     ab8:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     aba:	6c 01       	movw	r12, r24
     abc:	81 e1       	ldi	r24, 0x11	; 17
     abe:	c8 0e       	add	r12, r24
     ac0:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     ac2:	0f b6       	in	r0, 0x3f	; 63
     ac4:	f8 94       	cli
     ac6:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     ac8:	f8 01       	movw	r30, r16
     aca:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     acc:	ff 20       	and	r15, r15
     ace:	91 f1       	breq	.+100    	; 0xb34 <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     ad0:	c6 80       	ldd	r12, Z+6	; 0x06
     ad2:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     ad4:	b5 01       	movw	r22, r10
     ad6:	c8 01       	movw	r24, r16
     ad8:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     adc:	81 10       	cpse	r8, r1
     ade:	19 c0       	rjmp	.+50     	; 0xb12 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     ae0:	fa 94       	dec	r15
     ae2:	f8 01       	movw	r30, r16
     ae4:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     ae6:	80 81       	ld	r24, Z
     ae8:	91 81       	ldd	r25, Z+1	; 0x01
     aea:	89 2b       	or	r24, r25
     aec:	29 f4       	brne	.+10     	; 0xaf8 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     aee:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <pvTaskIncrementMutexHeldCount>
     af2:	f8 01       	movw	r30, r16
     af4:	93 83       	std	Z+3, r25	; 0x03
     af6:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     af8:	f8 01       	movw	r30, r16
     afa:	80 85       	ldd	r24, Z+8	; 0x08
     afc:	88 23       	and	r24, r24
     afe:	b1 f0       	breq	.+44     	; 0xb2c <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b00:	c8 01       	movw	r24, r16
     b02:	08 96       	adiw	r24, 0x08	; 8
     b04:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     b08:	88 23       	and	r24, r24
     b0a:	81 f0       	breq	.+32     	; 0xb2c <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
     b0c:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
     b10:	0d c0       	rjmp	.+26     	; 0xb2c <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     b12:	f8 01       	movw	r30, r16
     b14:	d7 82       	std	Z+7, r13	; 0x07
     b16:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     b18:	81 89       	ldd	r24, Z+17	; 0x11
     b1a:	88 23       	and	r24, r24
     b1c:	39 f0       	breq	.+14     	; 0xb2c <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     b1e:	c8 01       	movw	r24, r16
     b20:	41 96       	adiw	r24, 0x11	; 17
     b22:	0e 94 cb 09 	call	0x1396	; 0x1396 <xTaskRemoveFromEventList>
     b26:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     b28:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     b2c:	0f 90       	pop	r0
     b2e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     b30:	81 e0       	ldi	r24, 0x01	; 1
     b32:	64 c0       	rjmp	.+200    	; 0xbfc <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     b34:	8c 81       	ldd	r24, Y+4	; 0x04
     b36:	9d 81       	ldd	r25, Y+5	; 0x05
     b38:	89 2b       	or	r24, r25
     b3a:	21 f4       	brne	.+8      	; 0xb44 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b3c:	0f 90       	pop	r0
     b3e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	5c c0       	rjmp	.+184    	; 0xbfc <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
     b44:	e1 10       	cpse	r14, r1
     b46:	05 c0       	rjmp	.+10     	; 0xb52 <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b48:	ce 01       	movw	r24, r28
     b4a:	01 96       	adiw	r24, 0x01	; 1
     b4c:	0e 94 13 0a 	call	0x1426	; 0x1426 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b50:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b52:	0f 90       	pop	r0
     b54:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b56:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b5a:	0f b6       	in	r0, 0x3f	; 63
     b5c:	f8 94       	cli
     b5e:	0f 92       	push	r0
     b60:	f8 01       	movw	r30, r16
     b62:	85 8d       	ldd	r24, Z+29	; 0x1d
     b64:	8f 3f       	cpi	r24, 0xFF	; 255
     b66:	09 f4       	brne	.+2      	; 0xb6a <xQueueGenericReceive+0xe2>
     b68:	15 8e       	std	Z+29, r1	; 0x1d
     b6a:	f8 01       	movw	r30, r16
     b6c:	86 8d       	ldd	r24, Z+30	; 0x1e
     b6e:	8f 3f       	cpi	r24, 0xFF	; 255
     b70:	09 f4       	brne	.+2      	; 0xb74 <xQueueGenericReceive+0xec>
     b72:	16 8e       	std	Z+30, r1	; 0x1e
     b74:	0f 90       	pop	r0
     b76:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b78:	be 01       	movw	r22, r28
     b7a:	6c 5f       	subi	r22, 0xFC	; 252
     b7c:	7f 4f       	sbci	r23, 0xFF	; 255
     b7e:	ce 01       	movw	r24, r28
     b80:	01 96       	adiw	r24, 0x01	; 1
     b82:	0e 94 1e 0a 	call	0x143c	; 0x143c <xTaskCheckForTimeOut>
     b86:	81 11       	cpse	r24, r1
     b88:	2b c0       	rjmp	.+86     	; 0xbe0 <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b8a:	0f b6       	in	r0, 0x3f	; 63
     b8c:	f8 94       	cli
     b8e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     b90:	f8 01       	movw	r30, r16
     b92:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     b94:	0f 90       	pop	r0
     b96:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b98:	81 11       	cpse	r24, r1
     b9a:	1c c0       	rjmp	.+56     	; 0xbd4 <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b9c:	80 81       	ld	r24, Z
     b9e:	91 81       	ldd	r25, Z+1	; 0x01
     ba0:	89 2b       	or	r24, r25
     ba2:	49 f4       	brne	.+18     	; 0xbb6 <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
     ba4:	0f b6       	in	r0, 0x3f	; 63
     ba6:	f8 94       	cli
     ba8:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     baa:	82 81       	ldd	r24, Z+2	; 0x02
     bac:	93 81       	ldd	r25, Z+3	; 0x03
     bae:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     bb2:	0f 90       	pop	r0
     bb4:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     bb6:	6c 81       	ldd	r22, Y+4	; 0x04
     bb8:	7d 81       	ldd	r23, Y+5	; 0x05
     bba:	c6 01       	movw	r24, r12
     bbc:	0e 94 b9 09 	call	0x1372	; 0x1372 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     bc0:	c8 01       	movw	r24, r16
     bc2:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     bc6:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
     bca:	81 11       	cpse	r24, r1
     bcc:	7a cf       	rjmp	.-268    	; 0xac2 <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
     bce:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
     bd2:	77 cf       	rjmp	.-274    	; 0xac2 <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     bd4:	c8 01       	movw	r24, r16
     bd6:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     bda:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
     bde:	71 cf       	rjmp	.-286    	; 0xac2 <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     be0:	c8 01       	movw	r24, r16
     be2:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     be6:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     bea:	0f b6       	in	r0, 0x3f	; 63
     bec:	f8 94       	cli
     bee:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     bf0:	f8 01       	movw	r30, r16
     bf2:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     bf4:	0f 90       	pop	r0
     bf6:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     bf8:	81 11       	cpse	r24, r1
     bfa:	63 cf       	rjmp	.-314    	; 0xac2 <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     bfc:	0f 90       	pop	r0
     bfe:	0f 90       	pop	r0
     c00:	0f 90       	pop	r0
     c02:	0f 90       	pop	r0
     c04:	0f 90       	pop	r0
     c06:	df 91       	pop	r29
     c08:	cf 91       	pop	r28
     c0a:	1f 91       	pop	r17
     c0c:	0f 91       	pop	r16
     c0e:	ff 90       	pop	r15
     c10:	ef 90       	pop	r14
     c12:	df 90       	pop	r13
     c14:	cf 90       	pop	r12
     c16:	bf 90       	pop	r11
     c18:	af 90       	pop	r10
     c1a:	9f 90       	pop	r9
     c1c:	8f 90       	pop	r8
     c1e:	08 95       	ret

00000c20 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     c20:	e0 91 99 04 	lds	r30, 0x0499	; 0x800499 <pxDelayedTaskList>
     c24:	f0 91 9a 04 	lds	r31, 0x049A	; 0x80049a <pxDelayedTaskList+0x1>
     c28:	80 81       	ld	r24, Z
     c2a:	81 11       	cpse	r24, r1
     c2c:	07 c0       	rjmp	.+14     	; 0xc3c <prvResetNextTaskUnblockTime+0x1c>
     c2e:	8f ef       	ldi	r24, 0xFF	; 255
     c30:	9f ef       	ldi	r25, 0xFF	; 255
     c32:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <xNextTaskUnblockTime+0x1>
     c36:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <xNextTaskUnblockTime>
     c3a:	08 95       	ret
     c3c:	e0 91 99 04 	lds	r30, 0x0499	; 0x800499 <pxDelayedTaskList>
     c40:	f0 91 9a 04 	lds	r31, 0x049A	; 0x80049a <pxDelayedTaskList+0x1>
     c44:	05 80       	ldd	r0, Z+5	; 0x05
     c46:	f6 81       	ldd	r31, Z+6	; 0x06
     c48:	e0 2d       	mov	r30, r0
     c4a:	06 80       	ldd	r0, Z+6	; 0x06
     c4c:	f7 81       	ldd	r31, Z+7	; 0x07
     c4e:	e0 2d       	mov	r30, r0
     c50:	82 81       	ldd	r24, Z+2	; 0x02
     c52:	93 81       	ldd	r25, Z+3	; 0x03
     c54:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <xNextTaskUnblockTime+0x1>
     c58:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <xNextTaskUnblockTime>
     c5c:	08 95       	ret

00000c5e <prvAddCurrentTaskToDelayedList>:
     c5e:	ff 92       	push	r15
     c60:	0f 93       	push	r16
     c62:	1f 93       	push	r17
     c64:	cf 93       	push	r28
     c66:	df 93       	push	r29
     c68:	ec 01       	movw	r28, r24
     c6a:	f6 2e       	mov	r15, r22
     c6c:	00 91 78 04 	lds	r16, 0x0478	; 0x800478 <xTickCount>
     c70:	10 91 79 04 	lds	r17, 0x0479	; 0x800479 <xTickCount+0x1>
     c74:	80 91 da 04 	lds	r24, 0x04DA	; 0x8004da <pxCurrentTCB>
     c78:	90 91 db 04 	lds	r25, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     c7c:	02 96       	adiw	r24, 0x02	; 2
     c7e:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     c82:	cf 3f       	cpi	r28, 0xFF	; 255
     c84:	8f ef       	ldi	r24, 0xFF	; 255
     c86:	d8 07       	cpc	r29, r24
     c88:	69 f4       	brne	.+26     	; 0xca4 <prvAddCurrentTaskToDelayedList+0x46>
     c8a:	ff 20       	and	r15, r15
     c8c:	59 f0       	breq	.+22     	; 0xca4 <prvAddCurrentTaskToDelayedList+0x46>
     c8e:	60 91 da 04 	lds	r22, 0x04DA	; 0x8004da <pxCurrentTCB>
     c92:	70 91 db 04 	lds	r23, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     c96:	6e 5f       	subi	r22, 0xFE	; 254
     c98:	7f 4f       	sbci	r23, 0xFF	; 255
     c9a:	8b e7       	ldi	r24, 0x7B	; 123
     c9c:	94 e0       	ldi	r25, 0x04	; 4
     c9e:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
     ca2:	2f c0       	rjmp	.+94     	; 0xd02 <prvAddCurrentTaskToDelayedList+0xa4>
     ca4:	c0 0f       	add	r28, r16
     ca6:	d1 1f       	adc	r29, r17
     ca8:	e0 91 da 04 	lds	r30, 0x04DA	; 0x8004da <pxCurrentTCB>
     cac:	f0 91 db 04 	lds	r31, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     cb0:	d3 83       	std	Z+3, r29	; 0x03
     cb2:	c2 83       	std	Z+2, r28	; 0x02
     cb4:	c0 17       	cp	r28, r16
     cb6:	d1 07       	cpc	r29, r17
     cb8:	68 f4       	brcc	.+26     	; 0xcd4 <prvAddCurrentTaskToDelayedList+0x76>
     cba:	60 91 da 04 	lds	r22, 0x04DA	; 0x8004da <pxCurrentTCB>
     cbe:	70 91 db 04 	lds	r23, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     cc2:	80 91 97 04 	lds	r24, 0x0497	; 0x800497 <pxOverflowDelayedTaskList>
     cc6:	90 91 98 04 	lds	r25, 0x0498	; 0x800498 <pxOverflowDelayedTaskList+0x1>
     cca:	6e 5f       	subi	r22, 0xFE	; 254
     ccc:	7f 4f       	sbci	r23, 0xFF	; 255
     cce:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     cd2:	17 c0       	rjmp	.+46     	; 0xd02 <prvAddCurrentTaskToDelayedList+0xa4>
     cd4:	60 91 da 04 	lds	r22, 0x04DA	; 0x8004da <pxCurrentTCB>
     cd8:	70 91 db 04 	lds	r23, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     cdc:	80 91 99 04 	lds	r24, 0x0499	; 0x800499 <pxDelayedTaskList>
     ce0:	90 91 9a 04 	lds	r25, 0x049A	; 0x80049a <pxDelayedTaskList+0x1>
     ce4:	6e 5f       	subi	r22, 0xFE	; 254
     ce6:	7f 4f       	sbci	r23, 0xFF	; 255
     ce8:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     cec:	80 91 70 04 	lds	r24, 0x0470	; 0x800470 <xNextTaskUnblockTime>
     cf0:	90 91 71 04 	lds	r25, 0x0471	; 0x800471 <xNextTaskUnblockTime+0x1>
     cf4:	c8 17       	cp	r28, r24
     cf6:	d9 07       	cpc	r29, r25
     cf8:	20 f4       	brcc	.+8      	; 0xd02 <prvAddCurrentTaskToDelayedList+0xa4>
     cfa:	d0 93 71 04 	sts	0x0471, r29	; 0x800471 <xNextTaskUnblockTime+0x1>
     cfe:	c0 93 70 04 	sts	0x0470, r28	; 0x800470 <xNextTaskUnblockTime>
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	1f 91       	pop	r17
     d08:	0f 91       	pop	r16
     d0a:	ff 90       	pop	r15
     d0c:	08 95       	ret

00000d0e <xTaskCreate>:
     d0e:	4f 92       	push	r4
     d10:	5f 92       	push	r5
     d12:	6f 92       	push	r6
     d14:	7f 92       	push	r7
     d16:	8f 92       	push	r8
     d18:	9f 92       	push	r9
     d1a:	af 92       	push	r10
     d1c:	bf 92       	push	r11
     d1e:	cf 92       	push	r12
     d20:	df 92       	push	r13
     d22:	ef 92       	push	r14
     d24:	ff 92       	push	r15
     d26:	0f 93       	push	r16
     d28:	1f 93       	push	r17
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	4c 01       	movw	r8, r24
     d30:	6b 01       	movw	r12, r22
     d32:	5a 01       	movw	r10, r20
     d34:	29 01       	movw	r4, r18
     d36:	ca 01       	movw	r24, r20
     d38:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     d3c:	3c 01       	movw	r6, r24
     d3e:	89 2b       	or	r24, r25
     d40:	09 f4       	brne	.+2      	; 0xd44 <xTaskCreate+0x36>
     d42:	e4 c0       	rjmp	.+456    	; 0xf0c <xTaskCreate+0x1fe>
     d44:	8a e2       	ldi	r24, 0x2A	; 42
     d46:	90 e0       	ldi	r25, 0x00	; 0
     d48:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     d4c:	ec 01       	movw	r28, r24
     d4e:	89 2b       	or	r24, r25
     d50:	71 f0       	breq	.+28     	; 0xd6e <xTaskCreate+0x60>
     d52:	78 8e       	std	Y+24, r7	; 0x18
     d54:	6f 8a       	std	Y+23, r6	; 0x17
     d56:	81 e0       	ldi	r24, 0x01	; 1
     d58:	a8 1a       	sub	r10, r24
     d5a:	b1 08       	sbc	r11, r1
     d5c:	6a 0c       	add	r6, r10
     d5e:	7b 1c       	adc	r7, r11
     d60:	d6 01       	movw	r26, r12
     d62:	8c 91       	ld	r24, X
     d64:	89 8f       	std	Y+25, r24	; 0x19
     d66:	8c 91       	ld	r24, X
     d68:	81 11       	cpse	r24, r1
     d6a:	05 c0       	rjmp	.+10     	; 0xd76 <xTaskCreate+0x68>
     d6c:	18 c0       	rjmp	.+48     	; 0xd9e <xTaskCreate+0x90>
     d6e:	c3 01       	movw	r24, r6
     d70:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
     d74:	cb c0       	rjmp	.+406    	; 0xf0c <xTaskCreate+0x1fe>
     d76:	ae 01       	movw	r20, r28
     d78:	46 5e       	subi	r20, 0xE6	; 230
     d7a:	5f 4f       	sbci	r21, 0xFF	; 255
     d7c:	f6 01       	movw	r30, r12
     d7e:	31 96       	adiw	r30, 0x01	; 1
     d80:	ba e0       	ldi	r27, 0x0A	; 10
     d82:	cb 0e       	add	r12, r27
     d84:	d1 1c       	adc	r13, r1
     d86:	cf 01       	movw	r24, r30
     d88:	21 91       	ld	r18, Z+
     d8a:	da 01       	movw	r26, r20
     d8c:	2d 93       	st	X+, r18
     d8e:	ad 01       	movw	r20, r26
     d90:	dc 01       	movw	r26, r24
     d92:	8c 91       	ld	r24, X
     d94:	88 23       	and	r24, r24
     d96:	19 f0       	breq	.+6      	; 0xd9e <xTaskCreate+0x90>
     d98:	ce 16       	cp	r12, r30
     d9a:	df 06       	cpc	r13, r31
     d9c:	a1 f7       	brne	.-24     	; 0xd86 <xTaskCreate+0x78>
     d9e:	1a a2       	std	Y+34, r1	; 0x22
     da0:	05 30       	cpi	r16, 0x05	; 5
     da2:	08 f0       	brcs	.+2      	; 0xda6 <xTaskCreate+0x98>
     da4:	04 e0       	ldi	r16, 0x04	; 4
     da6:	0e 8b       	std	Y+22, r16	; 0x16
     da8:	0b a3       	std	Y+35, r16	; 0x23
     daa:	1c a2       	std	Y+36, r1	; 0x24
     dac:	6e 01       	movw	r12, r28
     dae:	b2 e0       	ldi	r27, 0x02	; 2
     db0:	cb 0e       	add	r12, r27
     db2:	d1 1c       	adc	r13, r1
     db4:	c6 01       	movw	r24, r12
     db6:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     dba:	ce 01       	movw	r24, r28
     dbc:	0c 96       	adiw	r24, 0x0c	; 12
     dbe:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     dc2:	d9 87       	std	Y+9, r29	; 0x09
     dc4:	c8 87       	std	Y+8, r28	; 0x08
     dc6:	85 e0       	ldi	r24, 0x05	; 5
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	80 1b       	sub	r24, r16
     dcc:	91 09       	sbc	r25, r1
     dce:	9d 87       	std	Y+13, r25	; 0x0d
     dd0:	8c 87       	std	Y+12, r24	; 0x0c
     dd2:	db 8b       	std	Y+19, r29	; 0x13
     dd4:	ca 8b       	std	Y+18, r28	; 0x12
     dd6:	1d a2       	std	Y+37, r1	; 0x25
     dd8:	1e a2       	std	Y+38, r1	; 0x26
     dda:	1f a2       	std	Y+39, r1	; 0x27
     ddc:	18 a6       	std	Y+40, r1	; 0x28
     dde:	19 a6       	std	Y+41, r1	; 0x29
     de0:	a2 01       	movw	r20, r4
     de2:	b4 01       	movw	r22, r8
     de4:	c3 01       	movw	r24, r6
     de6:	0e 94 1a 02 	call	0x434	; 0x434 <pxPortInitialiseStack>
     dea:	99 83       	std	Y+1, r25	; 0x01
     dec:	88 83       	st	Y, r24
     dee:	e1 14       	cp	r14, r1
     df0:	f1 04       	cpc	r15, r1
     df2:	19 f0       	breq	.+6      	; 0xdfa <xTaskCreate+0xec>
     df4:	f7 01       	movw	r30, r14
     df6:	d1 83       	std	Z+1, r29	; 0x01
     df8:	c0 83       	st	Z, r28
     dfa:	0f b6       	in	r0, 0x3f	; 63
     dfc:	f8 94       	cli
     dfe:	0f 92       	push	r0
     e00:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <uxCurrentNumberOfTasks>
     e04:	8f 5f       	subi	r24, 0xFF	; 255
     e06:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <uxCurrentNumberOfTasks>
     e0a:	80 91 da 04 	lds	r24, 0x04DA	; 0x8004da <pxCurrentTCB>
     e0e:	90 91 db 04 	lds	r25, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     e12:	89 2b       	or	r24, r25
     e14:	d1 f5       	brne	.+116    	; 0xe8a <xTaskCreate+0x17c>
     e16:	d0 93 db 04 	sts	0x04DB, r29	; 0x8004db <pxCurrentTCB+0x1>
     e1a:	c0 93 da 04 	sts	0x04DA, r28	; 0x8004da <pxCurrentTCB>
     e1e:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <uxCurrentNumberOfTasks>
     e22:	81 30       	cpi	r24, 0x01	; 1
     e24:	09 f0       	breq	.+2      	; 0xe28 <xTaskCreate+0x11a>
     e26:	41 c0       	rjmp	.+130    	; 0xeaa <xTaskCreate+0x19c>
     e28:	0d ea       	ldi	r16, 0xAD	; 173
     e2a:	14 e0       	ldi	r17, 0x04	; 4
     e2c:	0f 2e       	mov	r0, r31
     e2e:	fa ed       	ldi	r31, 0xDA	; 218
     e30:	ef 2e       	mov	r14, r31
     e32:	f4 e0       	ldi	r31, 0x04	; 4
     e34:	ff 2e       	mov	r15, r31
     e36:	f0 2d       	mov	r31, r0
     e38:	c8 01       	movw	r24, r16
     e3a:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e3e:	07 5f       	subi	r16, 0xF7	; 247
     e40:	1f 4f       	sbci	r17, 0xFF	; 255
     e42:	0e 15       	cp	r16, r14
     e44:	1f 05       	cpc	r17, r15
     e46:	c1 f7       	brne	.-16     	; 0xe38 <xTaskCreate+0x12a>
     e48:	84 ea       	ldi	r24, 0xA4	; 164
     e4a:	94 e0       	ldi	r25, 0x04	; 4
     e4c:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e50:	8b e9       	ldi	r24, 0x9B	; 155
     e52:	94 e0       	ldi	r25, 0x04	; 4
     e54:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e58:	8e e8       	ldi	r24, 0x8E	; 142
     e5a:	94 e0       	ldi	r25, 0x04	; 4
     e5c:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e60:	85 e8       	ldi	r24, 0x85	; 133
     e62:	94 e0       	ldi	r25, 0x04	; 4
     e64:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e68:	8b e7       	ldi	r24, 0x7B	; 123
     e6a:	94 e0       	ldi	r25, 0x04	; 4
     e6c:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e70:	84 ea       	ldi	r24, 0xA4	; 164
     e72:	94 e0       	ldi	r25, 0x04	; 4
     e74:	90 93 9a 04 	sts	0x049A, r25	; 0x80049a <pxDelayedTaskList+0x1>
     e78:	80 93 99 04 	sts	0x0499, r24	; 0x800499 <pxDelayedTaskList>
     e7c:	8b e9       	ldi	r24, 0x9B	; 155
     e7e:	94 e0       	ldi	r25, 0x04	; 4
     e80:	90 93 98 04 	sts	0x0498, r25	; 0x800498 <pxOverflowDelayedTaskList+0x1>
     e84:	80 93 97 04 	sts	0x0497, r24	; 0x800497 <pxOverflowDelayedTaskList>
     e88:	10 c0       	rjmp	.+32     	; 0xeaa <xTaskCreate+0x19c>
     e8a:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <xSchedulerRunning>
     e8e:	81 11       	cpse	r24, r1
     e90:	0c c0       	rjmp	.+24     	; 0xeaa <xTaskCreate+0x19c>
     e92:	e0 91 da 04 	lds	r30, 0x04DA	; 0x8004da <pxCurrentTCB>
     e96:	f0 91 db 04 	lds	r31, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     e9a:	96 89       	ldd	r25, Z+22	; 0x16
     e9c:	8e 89       	ldd	r24, Y+22	; 0x16
     e9e:	89 17       	cp	r24, r25
     ea0:	20 f0       	brcs	.+8      	; 0xeaa <xTaskCreate+0x19c>
     ea2:	d0 93 db 04 	sts	0x04DB, r29	; 0x8004db <pxCurrentTCB+0x1>
     ea6:	c0 93 da 04 	sts	0x04DA, r28	; 0x8004da <pxCurrentTCB>
     eaa:	80 91 72 04 	lds	r24, 0x0472	; 0x800472 <uxTaskNumber>
     eae:	8f 5f       	subi	r24, 0xFF	; 255
     eb0:	80 93 72 04 	sts	0x0472, r24	; 0x800472 <uxTaskNumber>
     eb4:	8e 89       	ldd	r24, Y+22	; 0x16
     eb6:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <uxTopReadyPriority>
     eba:	98 17       	cp	r25, r24
     ebc:	10 f4       	brcc	.+4      	; 0xec2 <xTaskCreate+0x1b4>
     ebe:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <uxTopReadyPriority>
     ec2:	90 e0       	ldi	r25, 0x00	; 0
     ec4:	9c 01       	movw	r18, r24
     ec6:	22 0f       	add	r18, r18
     ec8:	33 1f       	adc	r19, r19
     eca:	22 0f       	add	r18, r18
     ecc:	33 1f       	adc	r19, r19
     ece:	22 0f       	add	r18, r18
     ed0:	33 1f       	adc	r19, r19
     ed2:	82 0f       	add	r24, r18
     ed4:	93 1f       	adc	r25, r19
     ed6:	b6 01       	movw	r22, r12
     ed8:	83 55       	subi	r24, 0x53	; 83
     eda:	9b 4f       	sbci	r25, 0xFB	; 251
     edc:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
     ee0:	0f 90       	pop	r0
     ee2:	0f be       	out	0x3f, r0	; 63
     ee4:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <xSchedulerRunning>
     ee8:	88 23       	and	r24, r24
     eea:	61 f0       	breq	.+24     	; 0xf04 <xTaskCreate+0x1f6>
     eec:	e0 91 da 04 	lds	r30, 0x04DA	; 0x8004da <pxCurrentTCB>
     ef0:	f0 91 db 04 	lds	r31, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
     ef4:	96 89       	ldd	r25, Z+22	; 0x16
     ef6:	8e 89       	ldd	r24, Y+22	; 0x16
     ef8:	98 17       	cp	r25, r24
     efa:	30 f4       	brcc	.+12     	; 0xf08 <xTaskCreate+0x1fa>
     efc:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
     f00:	81 e0       	ldi	r24, 0x01	; 1
     f02:	05 c0       	rjmp	.+10     	; 0xf0e <xTaskCreate+0x200>
     f04:	81 e0       	ldi	r24, 0x01	; 1
     f06:	03 c0       	rjmp	.+6      	; 0xf0e <xTaskCreate+0x200>
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	01 c0       	rjmp	.+2      	; 0xf0e <xTaskCreate+0x200>
     f0c:	8f ef       	ldi	r24, 0xFF	; 255
     f0e:	df 91       	pop	r29
     f10:	cf 91       	pop	r28
     f12:	1f 91       	pop	r17
     f14:	0f 91       	pop	r16
     f16:	ff 90       	pop	r15
     f18:	ef 90       	pop	r14
     f1a:	df 90       	pop	r13
     f1c:	cf 90       	pop	r12
     f1e:	bf 90       	pop	r11
     f20:	af 90       	pop	r10
     f22:	9f 90       	pop	r9
     f24:	8f 90       	pop	r8
     f26:	7f 90       	pop	r7
     f28:	6f 90       	pop	r6
     f2a:	5f 90       	pop	r5
     f2c:	4f 90       	pop	r4
     f2e:	08 95       	ret

00000f30 <vTaskStartScheduler>:
     f30:	ef 92       	push	r14
     f32:	ff 92       	push	r15
     f34:	0f 93       	push	r16
     f36:	0f 2e       	mov	r0, r31
     f38:	fe e6       	ldi	r31, 0x6E	; 110
     f3a:	ef 2e       	mov	r14, r31
     f3c:	f4 e0       	ldi	r31, 0x04	; 4
     f3e:	ff 2e       	mov	r15, r31
     f40:	f0 2d       	mov	r31, r0
     f42:	00 e0       	ldi	r16, 0x00	; 0
     f44:	20 e0       	ldi	r18, 0x00	; 0
     f46:	30 e0       	ldi	r19, 0x00	; 0
     f48:	44 e6       	ldi	r20, 0x64	; 100
     f4a:	50 e0       	ldi	r21, 0x00	; 0
     f4c:	67 e7       	ldi	r22, 0x77	; 119
     f4e:	70 e0       	ldi	r23, 0x00	; 0
     f50:	86 e1       	ldi	r24, 0x16	; 22
     f52:	99 e0       	ldi	r25, 0x09	; 9
     f54:	0e 94 87 06 	call	0xd0e	; 0xd0e <xTaskCreate>
     f58:	81 30       	cpi	r24, 0x01	; 1
     f5a:	81 f4       	brne	.+32     	; 0xf7c <vTaskStartScheduler+0x4c>
     f5c:	f8 94       	cli
     f5e:	8f ef       	ldi	r24, 0xFF	; 255
     f60:	9f ef       	ldi	r25, 0xFF	; 255
     f62:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <xNextTaskUnblockTime+0x1>
     f66:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <xNextTaskUnblockTime>
     f6a:	81 e0       	ldi	r24, 0x01	; 1
     f6c:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <xSchedulerRunning>
     f70:	10 92 79 04 	sts	0x0479, r1	; 0x800479 <xTickCount+0x1>
     f74:	10 92 78 04 	sts	0x0478, r1	; 0x800478 <xTickCount>
     f78:	0e 94 86 02 	call	0x50c	; 0x50c <xPortStartScheduler>
     f7c:	0f 91       	pop	r16
     f7e:	ff 90       	pop	r15
     f80:	ef 90       	pop	r14
     f82:	08 95       	ret

00000f84 <vTaskSuspendAll>:
     f84:	80 91 6d 04 	lds	r24, 0x046D	; 0x80046d <uxSchedulerSuspended>
     f88:	8f 5f       	subi	r24, 0xFF	; 255
     f8a:	80 93 6d 04 	sts	0x046D, r24	; 0x80046d <uxSchedulerSuspended>
     f8e:	08 95       	ret

00000f90 <xTaskIncrementTick>:
     f90:	cf 92       	push	r12
     f92:	df 92       	push	r13
     f94:	ef 92       	push	r14
     f96:	ff 92       	push	r15
     f98:	0f 93       	push	r16
     f9a:	1f 93       	push	r17
     f9c:	cf 93       	push	r28
     f9e:	df 93       	push	r29
     fa0:	80 91 6d 04 	lds	r24, 0x046D	; 0x80046d <uxSchedulerSuspended>
     fa4:	81 11       	cpse	r24, r1
     fa6:	99 c0       	rjmp	.+306    	; 0x10da <xTaskIncrementTick+0x14a>
     fa8:	e0 90 78 04 	lds	r14, 0x0478	; 0x800478 <xTickCount>
     fac:	f0 90 79 04 	lds	r15, 0x0479	; 0x800479 <xTickCount+0x1>
     fb0:	8f ef       	ldi	r24, 0xFF	; 255
     fb2:	e8 1a       	sub	r14, r24
     fb4:	f8 0a       	sbc	r15, r24
     fb6:	f0 92 79 04 	sts	0x0479, r15	; 0x800479 <xTickCount+0x1>
     fba:	e0 92 78 04 	sts	0x0478, r14	; 0x800478 <xTickCount>
     fbe:	e1 14       	cp	r14, r1
     fc0:	f1 04       	cpc	r15, r1
     fc2:	b9 f4       	brne	.+46     	; 0xff2 <xTaskIncrementTick+0x62>
     fc4:	80 91 99 04 	lds	r24, 0x0499	; 0x800499 <pxDelayedTaskList>
     fc8:	90 91 9a 04 	lds	r25, 0x049A	; 0x80049a <pxDelayedTaskList+0x1>
     fcc:	20 91 97 04 	lds	r18, 0x0497	; 0x800497 <pxOverflowDelayedTaskList>
     fd0:	30 91 98 04 	lds	r19, 0x0498	; 0x800498 <pxOverflowDelayedTaskList+0x1>
     fd4:	30 93 9a 04 	sts	0x049A, r19	; 0x80049a <pxDelayedTaskList+0x1>
     fd8:	20 93 99 04 	sts	0x0499, r18	; 0x800499 <pxDelayedTaskList>
     fdc:	90 93 98 04 	sts	0x0498, r25	; 0x800498 <pxOverflowDelayedTaskList+0x1>
     fe0:	80 93 97 04 	sts	0x0497, r24	; 0x800497 <pxOverflowDelayedTaskList>
     fe4:	80 91 73 04 	lds	r24, 0x0473	; 0x800473 <xNumOfOverflows>
     fe8:	8f 5f       	subi	r24, 0xFF	; 255
     fea:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <xNumOfOverflows>
     fee:	0e 94 10 06 	call	0xc20	; 0xc20 <prvResetNextTaskUnblockTime>
     ff2:	80 91 70 04 	lds	r24, 0x0470	; 0x800470 <xNextTaskUnblockTime>
     ff6:	90 91 71 04 	lds	r25, 0x0471	; 0x800471 <xNextTaskUnblockTime+0x1>
     ffa:	e8 16       	cp	r14, r24
     ffc:	f9 06       	cpc	r15, r25
     ffe:	10 f4       	brcc	.+4      	; 0x1004 <xTaskIncrementTick+0x74>
    1000:	d1 2c       	mov	r13, r1
    1002:	53 c0       	rjmp	.+166    	; 0x10aa <xTaskIncrementTick+0x11a>
    1004:	d1 2c       	mov	r13, r1
    1006:	cc 24       	eor	r12, r12
    1008:	c3 94       	inc	r12
    100a:	e0 91 99 04 	lds	r30, 0x0499	; 0x800499 <pxDelayedTaskList>
    100e:	f0 91 9a 04 	lds	r31, 0x049A	; 0x80049a <pxDelayedTaskList+0x1>
    1012:	80 81       	ld	r24, Z
    1014:	81 11       	cpse	r24, r1
    1016:	07 c0       	rjmp	.+14     	; 0x1026 <xTaskIncrementTick+0x96>
    1018:	8f ef       	ldi	r24, 0xFF	; 255
    101a:	9f ef       	ldi	r25, 0xFF	; 255
    101c:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <xNextTaskUnblockTime+0x1>
    1020:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <xNextTaskUnblockTime>
    1024:	42 c0       	rjmp	.+132    	; 0x10aa <xTaskIncrementTick+0x11a>
    1026:	e0 91 99 04 	lds	r30, 0x0499	; 0x800499 <pxDelayedTaskList>
    102a:	f0 91 9a 04 	lds	r31, 0x049A	; 0x80049a <pxDelayedTaskList+0x1>
    102e:	05 80       	ldd	r0, Z+5	; 0x05
    1030:	f6 81       	ldd	r31, Z+6	; 0x06
    1032:	e0 2d       	mov	r30, r0
    1034:	c6 81       	ldd	r28, Z+6	; 0x06
    1036:	d7 81       	ldd	r29, Z+7	; 0x07
    1038:	8a 81       	ldd	r24, Y+2	; 0x02
    103a:	9b 81       	ldd	r25, Y+3	; 0x03
    103c:	e8 16       	cp	r14, r24
    103e:	f9 06       	cpc	r15, r25
    1040:	28 f4       	brcc	.+10     	; 0x104c <xTaskIncrementTick+0xbc>
    1042:	90 93 71 04 	sts	0x0471, r25	; 0x800471 <xNextTaskUnblockTime+0x1>
    1046:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <xNextTaskUnblockTime>
    104a:	2f c0       	rjmp	.+94     	; 0x10aa <xTaskIncrementTick+0x11a>
    104c:	8e 01       	movw	r16, r28
    104e:	0e 5f       	subi	r16, 0xFE	; 254
    1050:	1f 4f       	sbci	r17, 0xFF	; 255
    1052:	c8 01       	movw	r24, r16
    1054:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    1058:	8c 89       	ldd	r24, Y+20	; 0x14
    105a:	9d 89       	ldd	r25, Y+21	; 0x15
    105c:	89 2b       	or	r24, r25
    105e:	21 f0       	breq	.+8      	; 0x1068 <xTaskIncrementTick+0xd8>
    1060:	ce 01       	movw	r24, r28
    1062:	0c 96       	adiw	r24, 0x0c	; 12
    1064:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    1068:	8e 89       	ldd	r24, Y+22	; 0x16
    106a:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <uxTopReadyPriority>
    106e:	98 17       	cp	r25, r24
    1070:	10 f4       	brcc	.+4      	; 0x1076 <xTaskIncrementTick+0xe6>
    1072:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <uxTopReadyPriority>
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	9c 01       	movw	r18, r24
    107a:	22 0f       	add	r18, r18
    107c:	33 1f       	adc	r19, r19
    107e:	22 0f       	add	r18, r18
    1080:	33 1f       	adc	r19, r19
    1082:	22 0f       	add	r18, r18
    1084:	33 1f       	adc	r19, r19
    1086:	82 0f       	add	r24, r18
    1088:	93 1f       	adc	r25, r19
    108a:	b8 01       	movw	r22, r16
    108c:	83 55       	subi	r24, 0x53	; 83
    108e:	9b 4f       	sbci	r25, 0xFB	; 251
    1090:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    1094:	e0 91 da 04 	lds	r30, 0x04DA	; 0x8004da <pxCurrentTCB>
    1098:	f0 91 db 04 	lds	r31, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    109c:	9e 89       	ldd	r25, Y+22	; 0x16
    109e:	86 89       	ldd	r24, Z+22	; 0x16
    10a0:	98 17       	cp	r25, r24
    10a2:	08 f4       	brcc	.+2      	; 0x10a6 <xTaskIncrementTick+0x116>
    10a4:	b2 cf       	rjmp	.-156    	; 0x100a <xTaskIncrementTick+0x7a>
    10a6:	dc 2c       	mov	r13, r12
    10a8:	b0 cf       	rjmp	.-160    	; 0x100a <xTaskIncrementTick+0x7a>
    10aa:	e0 91 da 04 	lds	r30, 0x04DA	; 0x8004da <pxCurrentTCB>
    10ae:	f0 91 db 04 	lds	r31, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    10b2:	86 89       	ldd	r24, Z+22	; 0x16
    10b4:	90 e0       	ldi	r25, 0x00	; 0
    10b6:	fc 01       	movw	r30, r24
    10b8:	ee 0f       	add	r30, r30
    10ba:	ff 1f       	adc	r31, r31
    10bc:	ee 0f       	add	r30, r30
    10be:	ff 1f       	adc	r31, r31
    10c0:	ee 0f       	add	r30, r30
    10c2:	ff 1f       	adc	r31, r31
    10c4:	8e 0f       	add	r24, r30
    10c6:	9f 1f       	adc	r25, r31
    10c8:	fc 01       	movw	r30, r24
    10ca:	e3 55       	subi	r30, 0x53	; 83
    10cc:	fb 4f       	sbci	r31, 0xFB	; 251
    10ce:	80 81       	ld	r24, Z
    10d0:	82 30       	cpi	r24, 0x02	; 2
    10d2:	48 f0       	brcs	.+18     	; 0x10e6 <xTaskIncrementTick+0x156>
    10d4:	dd 24       	eor	r13, r13
    10d6:	d3 94       	inc	r13
    10d8:	06 c0       	rjmp	.+12     	; 0x10e6 <xTaskIncrementTick+0x156>
    10da:	80 91 75 04 	lds	r24, 0x0475	; 0x800475 <uxPendedTicks>
    10de:	8f 5f       	subi	r24, 0xFF	; 255
    10e0:	80 93 75 04 	sts	0x0475, r24	; 0x800475 <uxPendedTicks>
    10e4:	d1 2c       	mov	r13, r1
    10e6:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <xYieldPending>
    10ea:	88 23       	and	r24, r24
    10ec:	11 f0       	breq	.+4      	; 0x10f2 <xTaskIncrementTick+0x162>
    10ee:	dd 24       	eor	r13, r13
    10f0:	d3 94       	inc	r13
    10f2:	8d 2d       	mov	r24, r13
    10f4:	df 91       	pop	r29
    10f6:	cf 91       	pop	r28
    10f8:	1f 91       	pop	r17
    10fa:	0f 91       	pop	r16
    10fc:	ff 90       	pop	r15
    10fe:	ef 90       	pop	r14
    1100:	df 90       	pop	r13
    1102:	cf 90       	pop	r12
    1104:	08 95       	ret

00001106 <xTaskResumeAll>:
    1106:	df 92       	push	r13
    1108:	ef 92       	push	r14
    110a:	ff 92       	push	r15
    110c:	0f 93       	push	r16
    110e:	1f 93       	push	r17
    1110:	cf 93       	push	r28
    1112:	df 93       	push	r29
    1114:	0f b6       	in	r0, 0x3f	; 63
    1116:	f8 94       	cli
    1118:	0f 92       	push	r0
    111a:	80 91 6d 04 	lds	r24, 0x046D	; 0x80046d <uxSchedulerSuspended>
    111e:	81 50       	subi	r24, 0x01	; 1
    1120:	80 93 6d 04 	sts	0x046D, r24	; 0x80046d <uxSchedulerSuspended>
    1124:	80 91 6d 04 	lds	r24, 0x046D	; 0x80046d <uxSchedulerSuspended>
    1128:	81 11       	cpse	r24, r1
    112a:	5f c0       	rjmp	.+190    	; 0x11ea <xTaskResumeAll+0xe4>
    112c:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <uxCurrentNumberOfTasks>
    1130:	81 11       	cpse	r24, r1
    1132:	33 c0       	rjmp	.+102    	; 0x119a <xTaskResumeAll+0x94>
    1134:	5d c0       	rjmp	.+186    	; 0x11f0 <xTaskResumeAll+0xea>
    1136:	d7 01       	movw	r26, r14
    1138:	15 96       	adiw	r26, 0x05	; 5
    113a:	ed 91       	ld	r30, X+
    113c:	fc 91       	ld	r31, X
    113e:	16 97       	sbiw	r26, 0x06	; 6
    1140:	c6 81       	ldd	r28, Z+6	; 0x06
    1142:	d7 81       	ldd	r29, Z+7	; 0x07
    1144:	ce 01       	movw	r24, r28
    1146:	0c 96       	adiw	r24, 0x0c	; 12
    1148:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    114c:	8e 01       	movw	r16, r28
    114e:	0e 5f       	subi	r16, 0xFE	; 254
    1150:	1f 4f       	sbci	r17, 0xFF	; 255
    1152:	c8 01       	movw	r24, r16
    1154:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    1158:	8e 89       	ldd	r24, Y+22	; 0x16
    115a:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <uxTopReadyPriority>
    115e:	98 17       	cp	r25, r24
    1160:	10 f4       	brcc	.+4      	; 0x1166 <xTaskResumeAll+0x60>
    1162:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <uxTopReadyPriority>
    1166:	90 e0       	ldi	r25, 0x00	; 0
    1168:	9c 01       	movw	r18, r24
    116a:	22 0f       	add	r18, r18
    116c:	33 1f       	adc	r19, r19
    116e:	22 0f       	add	r18, r18
    1170:	33 1f       	adc	r19, r19
    1172:	22 0f       	add	r18, r18
    1174:	33 1f       	adc	r19, r19
    1176:	82 0f       	add	r24, r18
    1178:	93 1f       	adc	r25, r19
    117a:	b8 01       	movw	r22, r16
    117c:	83 55       	subi	r24, 0x53	; 83
    117e:	9b 4f       	sbci	r25, 0xFB	; 251
    1180:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    1184:	e0 91 da 04 	lds	r30, 0x04DA	; 0x8004da <pxCurrentTCB>
    1188:	f0 91 db 04 	lds	r31, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    118c:	9e 89       	ldd	r25, Y+22	; 0x16
    118e:	86 89       	ldd	r24, Z+22	; 0x16
    1190:	98 17       	cp	r25, r24
    1192:	68 f0       	brcs	.+26     	; 0x11ae <xTaskResumeAll+0xa8>
    1194:	d0 92 74 04 	sts	0x0474, r13	; 0x800474 <xYieldPending>
    1198:	0a c0       	rjmp	.+20     	; 0x11ae <xTaskResumeAll+0xa8>
    119a:	c0 e0       	ldi	r28, 0x00	; 0
    119c:	d0 e0       	ldi	r29, 0x00	; 0
    119e:	0f 2e       	mov	r0, r31
    11a0:	fe e8       	ldi	r31, 0x8E	; 142
    11a2:	ef 2e       	mov	r14, r31
    11a4:	f4 e0       	ldi	r31, 0x04	; 4
    11a6:	ff 2e       	mov	r15, r31
    11a8:	f0 2d       	mov	r31, r0
    11aa:	dd 24       	eor	r13, r13
    11ac:	d3 94       	inc	r13
    11ae:	f7 01       	movw	r30, r14
    11b0:	80 81       	ld	r24, Z
    11b2:	81 11       	cpse	r24, r1
    11b4:	c0 cf       	rjmp	.-128    	; 0x1136 <xTaskResumeAll+0x30>
    11b6:	cd 2b       	or	r28, r29
    11b8:	11 f0       	breq	.+4      	; 0x11be <xTaskResumeAll+0xb8>
    11ba:	0e 94 10 06 	call	0xc20	; 0xc20 <prvResetNextTaskUnblockTime>
    11be:	c0 91 75 04 	lds	r28, 0x0475	; 0x800475 <uxPendedTicks>
    11c2:	cc 23       	and	r28, r28
    11c4:	51 f0       	breq	.+20     	; 0x11da <xTaskResumeAll+0xd4>
    11c6:	d1 e0       	ldi	r29, 0x01	; 1
    11c8:	0e 94 c8 07 	call	0xf90	; 0xf90 <xTaskIncrementTick>
    11cc:	81 11       	cpse	r24, r1
    11ce:	d0 93 74 04 	sts	0x0474, r29	; 0x800474 <xYieldPending>
    11d2:	c1 50       	subi	r28, 0x01	; 1
    11d4:	c9 f7       	brne	.-14     	; 0x11c8 <xTaskResumeAll+0xc2>
    11d6:	10 92 75 04 	sts	0x0475, r1	; 0x800475 <uxPendedTicks>
    11da:	80 91 74 04 	lds	r24, 0x0474	; 0x800474 <xYieldPending>
    11de:	88 23       	and	r24, r24
    11e0:	31 f0       	breq	.+12     	; 0x11ee <xTaskResumeAll+0xe8>
    11e2:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
    11e6:	81 e0       	ldi	r24, 0x01	; 1
    11e8:	03 c0       	rjmp	.+6      	; 0x11f0 <xTaskResumeAll+0xea>
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	01 c0       	rjmp	.+2      	; 0x11f0 <xTaskResumeAll+0xea>
    11ee:	80 e0       	ldi	r24, 0x00	; 0
    11f0:	0f 90       	pop	r0
    11f2:	0f be       	out	0x3f, r0	; 63
    11f4:	df 91       	pop	r29
    11f6:	cf 91       	pop	r28
    11f8:	1f 91       	pop	r17
    11fa:	0f 91       	pop	r16
    11fc:	ff 90       	pop	r15
    11fe:	ef 90       	pop	r14
    1200:	df 90       	pop	r13
    1202:	08 95       	ret

00001204 <vTaskDelay>:
    1204:	cf 93       	push	r28
    1206:	df 93       	push	r29
    1208:	ec 01       	movw	r28, r24
    120a:	89 2b       	or	r24, r25
    120c:	51 f0       	breq	.+20     	; 0x1222 <vTaskDelay+0x1e>
    120e:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
    1212:	60 e0       	ldi	r22, 0x00	; 0
    1214:	ce 01       	movw	r24, r28
    1216:	0e 94 2f 06 	call	0xc5e	; 0xc5e <prvAddCurrentTaskToDelayedList>
    121a:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
    121e:	81 11       	cpse	r24, r1
    1220:	02 c0       	rjmp	.+4      	; 0x1226 <vTaskDelay+0x22>
    1222:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
    1226:	df 91       	pop	r29
    1228:	cf 91       	pop	r28
    122a:	08 95       	ret

0000122c <prvIdleTask>:
    122c:	05 e8       	ldi	r16, 0x85	; 133
    122e:	14 e0       	ldi	r17, 0x04	; 4
    1230:	0f 2e       	mov	r0, r31
    1232:	fd ea       	ldi	r31, 0xAD	; 173
    1234:	ef 2e       	mov	r14, r31
    1236:	f4 e0       	ldi	r31, 0x04	; 4
    1238:	ff 2e       	mov	r15, r31
    123a:	f0 2d       	mov	r31, r0
    123c:	29 c0       	rjmp	.+82     	; 0x1290 <prvIdleTask+0x64>
    123e:	0e 94 c2 07 	call	0xf84	; 0xf84 <vTaskSuspendAll>
    1242:	d8 01       	movw	r26, r16
    1244:	cc 91       	ld	r28, X
    1246:	0e 94 83 08 	call	0x1106	; 0x1106 <xTaskResumeAll>
    124a:	cc 23       	and	r28, r28
    124c:	09 f1       	breq	.+66     	; 0x1290 <prvIdleTask+0x64>
    124e:	0f b6       	in	r0, 0x3f	; 63
    1250:	f8 94       	cli
    1252:	0f 92       	push	r0
    1254:	d8 01       	movw	r26, r16
    1256:	15 96       	adiw	r26, 0x05	; 5
    1258:	ed 91       	ld	r30, X+
    125a:	fc 91       	ld	r31, X
    125c:	16 97       	sbiw	r26, 0x06	; 6
    125e:	c6 81       	ldd	r28, Z+6	; 0x06
    1260:	d7 81       	ldd	r29, Z+7	; 0x07
    1262:	ce 01       	movw	r24, r28
    1264:	02 96       	adiw	r24, 0x02	; 2
    1266:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    126a:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <uxCurrentNumberOfTasks>
    126e:	81 50       	subi	r24, 0x01	; 1
    1270:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <uxCurrentNumberOfTasks>
    1274:	80 91 84 04 	lds	r24, 0x0484	; 0x800484 <uxDeletedTasksWaitingCleanUp>
    1278:	81 50       	subi	r24, 0x01	; 1
    127a:	80 93 84 04 	sts	0x0484, r24	; 0x800484 <uxDeletedTasksWaitingCleanUp>
    127e:	0f 90       	pop	r0
    1280:	0f be       	out	0x3f, r0	; 63
    1282:	8f 89       	ldd	r24, Y+23	; 0x17
    1284:	98 8d       	ldd	r25, Y+24	; 0x18
    1286:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
    128a:	ce 01       	movw	r24, r28
    128c:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
    1290:	80 91 84 04 	lds	r24, 0x0484	; 0x800484 <uxDeletedTasksWaitingCleanUp>
    1294:	81 11       	cpse	r24, r1
    1296:	d3 cf       	rjmp	.-90     	; 0x123e <prvIdleTask+0x12>
    1298:	f7 01       	movw	r30, r14
    129a:	80 81       	ld	r24, Z
    129c:	82 30       	cpi	r24, 0x02	; 2
    129e:	c0 f3       	brcs	.-16     	; 0x1290 <prvIdleTask+0x64>
    12a0:	0e 94 bb 02 	call	0x576	; 0x576 <vPortYield>
    12a4:	f5 cf       	rjmp	.-22     	; 0x1290 <prvIdleTask+0x64>

000012a6 <vTaskSwitchContext>:
    12a6:	80 91 6d 04 	lds	r24, 0x046D	; 0x80046d <uxSchedulerSuspended>
    12aa:	88 23       	and	r24, r24
    12ac:	21 f0       	breq	.+8      	; 0x12b6 <vTaskSwitchContext+0x10>
    12ae:	81 e0       	ldi	r24, 0x01	; 1
    12b0:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <xYieldPending>
    12b4:	08 95       	ret
    12b6:	10 92 74 04 	sts	0x0474, r1	; 0x800474 <xYieldPending>
    12ba:	20 91 77 04 	lds	r18, 0x0477	; 0x800477 <uxTopReadyPriority>
    12be:	82 2f       	mov	r24, r18
    12c0:	90 e0       	ldi	r25, 0x00	; 0
    12c2:	fc 01       	movw	r30, r24
    12c4:	ee 0f       	add	r30, r30
    12c6:	ff 1f       	adc	r31, r31
    12c8:	ee 0f       	add	r30, r30
    12ca:	ff 1f       	adc	r31, r31
    12cc:	ee 0f       	add	r30, r30
    12ce:	ff 1f       	adc	r31, r31
    12d0:	e8 0f       	add	r30, r24
    12d2:	f9 1f       	adc	r31, r25
    12d4:	e3 55       	subi	r30, 0x53	; 83
    12d6:	fb 4f       	sbci	r31, 0xFB	; 251
    12d8:	30 81       	ld	r19, Z
    12da:	31 11       	cpse	r19, r1
    12dc:	11 c0       	rjmp	.+34     	; 0x1300 <vTaskSwitchContext+0x5a>
    12de:	21 50       	subi	r18, 0x01	; 1
    12e0:	82 2f       	mov	r24, r18
    12e2:	90 e0       	ldi	r25, 0x00	; 0
    12e4:	fc 01       	movw	r30, r24
    12e6:	ee 0f       	add	r30, r30
    12e8:	ff 1f       	adc	r31, r31
    12ea:	ee 0f       	add	r30, r30
    12ec:	ff 1f       	adc	r31, r31
    12ee:	ee 0f       	add	r30, r30
    12f0:	ff 1f       	adc	r31, r31
    12f2:	e8 0f       	add	r30, r24
    12f4:	f9 1f       	adc	r31, r25
    12f6:	e3 55       	subi	r30, 0x53	; 83
    12f8:	fb 4f       	sbci	r31, 0xFB	; 251
    12fa:	30 81       	ld	r19, Z
    12fc:	33 23       	and	r19, r19
    12fe:	79 f3       	breq	.-34     	; 0x12de <vTaskSwitchContext+0x38>
    1300:	ac 01       	movw	r20, r24
    1302:	44 0f       	add	r20, r20
    1304:	55 1f       	adc	r21, r21
    1306:	44 0f       	add	r20, r20
    1308:	55 1f       	adc	r21, r21
    130a:	44 0f       	add	r20, r20
    130c:	55 1f       	adc	r21, r21
    130e:	48 0f       	add	r20, r24
    1310:	59 1f       	adc	r21, r25
    1312:	da 01       	movw	r26, r20
    1314:	a3 55       	subi	r26, 0x53	; 83
    1316:	bb 4f       	sbci	r27, 0xFB	; 251
    1318:	11 96       	adiw	r26, 0x01	; 1
    131a:	ed 91       	ld	r30, X+
    131c:	fc 91       	ld	r31, X
    131e:	12 97       	sbiw	r26, 0x02	; 2
    1320:	02 80       	ldd	r0, Z+2	; 0x02
    1322:	f3 81       	ldd	r31, Z+3	; 0x03
    1324:	e0 2d       	mov	r30, r0
    1326:	12 96       	adiw	r26, 0x02	; 2
    1328:	fc 93       	st	X, r31
    132a:	ee 93       	st	-X, r30
    132c:	11 97       	sbiw	r26, 0x01	; 1
    132e:	40 55       	subi	r20, 0x50	; 80
    1330:	5b 4f       	sbci	r21, 0xFB	; 251
    1332:	e4 17       	cp	r30, r20
    1334:	f5 07       	cpc	r31, r21
    1336:	29 f4       	brne	.+10     	; 0x1342 <vTaskSwitchContext+0x9c>
    1338:	42 81       	ldd	r20, Z+2	; 0x02
    133a:	53 81       	ldd	r21, Z+3	; 0x03
    133c:	fd 01       	movw	r30, r26
    133e:	52 83       	std	Z+2, r21	; 0x02
    1340:	41 83       	std	Z+1, r20	; 0x01
    1342:	fc 01       	movw	r30, r24
    1344:	ee 0f       	add	r30, r30
    1346:	ff 1f       	adc	r31, r31
    1348:	ee 0f       	add	r30, r30
    134a:	ff 1f       	adc	r31, r31
    134c:	ee 0f       	add	r30, r30
    134e:	ff 1f       	adc	r31, r31
    1350:	8e 0f       	add	r24, r30
    1352:	9f 1f       	adc	r25, r31
    1354:	fc 01       	movw	r30, r24
    1356:	e3 55       	subi	r30, 0x53	; 83
    1358:	fb 4f       	sbci	r31, 0xFB	; 251
    135a:	01 80       	ldd	r0, Z+1	; 0x01
    135c:	f2 81       	ldd	r31, Z+2	; 0x02
    135e:	e0 2d       	mov	r30, r0
    1360:	86 81       	ldd	r24, Z+6	; 0x06
    1362:	97 81       	ldd	r25, Z+7	; 0x07
    1364:	90 93 db 04 	sts	0x04DB, r25	; 0x8004db <pxCurrentTCB+0x1>
    1368:	80 93 da 04 	sts	0x04DA, r24	; 0x8004da <pxCurrentTCB>
    136c:	20 93 77 04 	sts	0x0477, r18	; 0x800477 <uxTopReadyPriority>
    1370:	08 95       	ret

00001372 <vTaskPlaceOnEventList>:
    1372:	cf 93       	push	r28
    1374:	df 93       	push	r29
    1376:	eb 01       	movw	r28, r22
    1378:	60 91 da 04 	lds	r22, 0x04DA	; 0x8004da <pxCurrentTCB>
    137c:	70 91 db 04 	lds	r23, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    1380:	64 5f       	subi	r22, 0xF4	; 244
    1382:	7f 4f       	sbci	r23, 0xFF	; 255
    1384:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
    1388:	61 e0       	ldi	r22, 0x01	; 1
    138a:	ce 01       	movw	r24, r28
    138c:	0e 94 2f 06 	call	0xc5e	; 0xc5e <prvAddCurrentTaskToDelayedList>
    1390:	df 91       	pop	r29
    1392:	cf 91       	pop	r28
    1394:	08 95       	ret

00001396 <xTaskRemoveFromEventList>:
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	cf 93       	push	r28
    139c:	df 93       	push	r29
    139e:	dc 01       	movw	r26, r24
    13a0:	15 96       	adiw	r26, 0x05	; 5
    13a2:	ed 91       	ld	r30, X+
    13a4:	fc 91       	ld	r31, X
    13a6:	16 97       	sbiw	r26, 0x06	; 6
    13a8:	c6 81       	ldd	r28, Z+6	; 0x06
    13aa:	d7 81       	ldd	r29, Z+7	; 0x07
    13ac:	8e 01       	movw	r16, r28
    13ae:	04 5f       	subi	r16, 0xF4	; 244
    13b0:	1f 4f       	sbci	r17, 0xFF	; 255
    13b2:	c8 01       	movw	r24, r16
    13b4:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    13b8:	80 91 6d 04 	lds	r24, 0x046D	; 0x80046d <uxSchedulerSuspended>
    13bc:	81 11       	cpse	r24, r1
    13be:	1c c0       	rjmp	.+56     	; 0x13f8 <xTaskRemoveFromEventList+0x62>
    13c0:	0a 50       	subi	r16, 0x0A	; 10
    13c2:	11 09       	sbc	r17, r1
    13c4:	c8 01       	movw	r24, r16
    13c6:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    13ca:	8e 89       	ldd	r24, Y+22	; 0x16
    13cc:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <uxTopReadyPriority>
    13d0:	98 17       	cp	r25, r24
    13d2:	10 f4       	brcc	.+4      	; 0x13d8 <xTaskRemoveFromEventList+0x42>
    13d4:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <uxTopReadyPriority>
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	9c 01       	movw	r18, r24
    13dc:	22 0f       	add	r18, r18
    13de:	33 1f       	adc	r19, r19
    13e0:	22 0f       	add	r18, r18
    13e2:	33 1f       	adc	r19, r19
    13e4:	22 0f       	add	r18, r18
    13e6:	33 1f       	adc	r19, r19
    13e8:	82 0f       	add	r24, r18
    13ea:	93 1f       	adc	r25, r19
    13ec:	b8 01       	movw	r22, r16
    13ee:	83 55       	subi	r24, 0x53	; 83
    13f0:	9b 4f       	sbci	r25, 0xFB	; 251
    13f2:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    13f6:	05 c0       	rjmp	.+10     	; 0x1402 <xTaskRemoveFromEventList+0x6c>
    13f8:	b8 01       	movw	r22, r16
    13fa:	8e e8       	ldi	r24, 0x8E	; 142
    13fc:	94 e0       	ldi	r25, 0x04	; 4
    13fe:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    1402:	e0 91 da 04 	lds	r30, 0x04DA	; 0x8004da <pxCurrentTCB>
    1406:	f0 91 db 04 	lds	r31, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    140a:	9e 89       	ldd	r25, Y+22	; 0x16
    140c:	86 89       	ldd	r24, Z+22	; 0x16
    140e:	89 17       	cp	r24, r25
    1410:	20 f4       	brcc	.+8      	; 0x141a <xTaskRemoveFromEventList+0x84>
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <xYieldPending>
    1418:	01 c0       	rjmp	.+2      	; 0x141c <xTaskRemoveFromEventList+0x86>
    141a:	80 e0       	ldi	r24, 0x00	; 0
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	08 95       	ret

00001426 <vTaskSetTimeOutState>:
    1426:	20 91 73 04 	lds	r18, 0x0473	; 0x800473 <xNumOfOverflows>
    142a:	fc 01       	movw	r30, r24
    142c:	20 83       	st	Z, r18
    142e:	20 91 78 04 	lds	r18, 0x0478	; 0x800478 <xTickCount>
    1432:	30 91 79 04 	lds	r19, 0x0479	; 0x800479 <xTickCount+0x1>
    1436:	32 83       	std	Z+2, r19	; 0x02
    1438:	21 83       	std	Z+1, r18	; 0x01
    143a:	08 95       	ret

0000143c <xTaskCheckForTimeOut>:
    143c:	0f b6       	in	r0, 0x3f	; 63
    143e:	f8 94       	cli
    1440:	0f 92       	push	r0
    1442:	40 91 78 04 	lds	r20, 0x0478	; 0x800478 <xTickCount>
    1446:	50 91 79 04 	lds	r21, 0x0479	; 0x800479 <xTickCount+0x1>
    144a:	db 01       	movw	r26, r22
    144c:	2d 91       	ld	r18, X+
    144e:	3c 91       	ld	r19, X
    1450:	2f 3f       	cpi	r18, 0xFF	; 255
    1452:	bf ef       	ldi	r27, 0xFF	; 255
    1454:	3b 07       	cpc	r19, r27
    1456:	19 f1       	breq	.+70     	; 0x149e <xTaskCheckForTimeOut+0x62>
    1458:	e0 91 73 04 	lds	r30, 0x0473	; 0x800473 <xNumOfOverflows>
    145c:	dc 01       	movw	r26, r24
    145e:	fc 91       	ld	r31, X
    1460:	fe 17       	cp	r31, r30
    1462:	39 f0       	breq	.+14     	; 0x1472 <xTaskCheckForTimeOut+0x36>
    1464:	11 96       	adiw	r26, 0x01	; 1
    1466:	ed 91       	ld	r30, X+
    1468:	fc 91       	ld	r31, X
    146a:	12 97       	sbiw	r26, 0x02	; 2
    146c:	4e 17       	cp	r20, r30
    146e:	5f 07       	cpc	r21, r31
    1470:	c0 f4       	brcc	.+48     	; 0x14a2 <xTaskCheckForTimeOut+0x66>
    1472:	dc 01       	movw	r26, r24
    1474:	11 96       	adiw	r26, 0x01	; 1
    1476:	ed 91       	ld	r30, X+
    1478:	fc 91       	ld	r31, X
    147a:	12 97       	sbiw	r26, 0x02	; 2
    147c:	da 01       	movw	r26, r20
    147e:	ae 1b       	sub	r26, r30
    1480:	bf 0b       	sbc	r27, r31
    1482:	a2 17       	cp	r26, r18
    1484:	b3 07       	cpc	r27, r19
    1486:	78 f4       	brcc	.+30     	; 0x14a6 <xTaskCheckForTimeOut+0x6a>
    1488:	db 01       	movw	r26, r22
    148a:	e4 1b       	sub	r30, r20
    148c:	f5 0b       	sbc	r31, r21
    148e:	2e 0f       	add	r18, r30
    1490:	3f 1f       	adc	r19, r31
    1492:	2d 93       	st	X+, r18
    1494:	3c 93       	st	X, r19
    1496:	0e 94 13 0a 	call	0x1426	; 0x1426 <vTaskSetTimeOutState>
    149a:	80 e0       	ldi	r24, 0x00	; 0
    149c:	05 c0       	rjmp	.+10     	; 0x14a8 <xTaskCheckForTimeOut+0x6c>
    149e:	80 e0       	ldi	r24, 0x00	; 0
    14a0:	03 c0       	rjmp	.+6      	; 0x14a8 <xTaskCheckForTimeOut+0x6c>
    14a2:	81 e0       	ldi	r24, 0x01	; 1
    14a4:	01 c0       	rjmp	.+2      	; 0x14a8 <xTaskCheckForTimeOut+0x6c>
    14a6:	81 e0       	ldi	r24, 0x01	; 1
    14a8:	0f 90       	pop	r0
    14aa:	0f be       	out	0x3f, r0	; 63
    14ac:	08 95       	ret

000014ae <vTaskMissedYield>:
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	80 93 74 04 	sts	0x0474, r24	; 0x800474 <xYieldPending>
    14b4:	08 95       	ret

000014b6 <vTaskPriorityInherit>:
    14b6:	0f 93       	push	r16
    14b8:	1f 93       	push	r17
    14ba:	cf 93       	push	r28
    14bc:	df 93       	push	r29
    14be:	fc 01       	movw	r30, r24
    14c0:	89 2b       	or	r24, r25
    14c2:	09 f4       	brne	.+2      	; 0x14c6 <vTaskPriorityInherit+0x10>
    14c4:	55 c0       	rjmp	.+170    	; 0x1570 <vTaskPriorityInherit+0xba>
    14c6:	26 89       	ldd	r18, Z+22	; 0x16
    14c8:	a0 91 da 04 	lds	r26, 0x04DA	; 0x8004da <pxCurrentTCB>
    14cc:	b0 91 db 04 	lds	r27, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    14d0:	56 96       	adiw	r26, 0x16	; 22
    14d2:	8c 91       	ld	r24, X
    14d4:	28 17       	cp	r18, r24
    14d6:	08 f0       	brcs	.+2      	; 0x14da <vTaskPriorityInherit+0x24>
    14d8:	4b c0       	rjmp	.+150    	; 0x1570 <vTaskPriorityInherit+0xba>
    14da:	84 85       	ldd	r24, Z+12	; 0x0c
    14dc:	95 85       	ldd	r25, Z+13	; 0x0d
    14de:	99 23       	and	r25, r25
    14e0:	64 f0       	brlt	.+24     	; 0x14fa <vTaskPriorityInherit+0x44>
    14e2:	a0 91 da 04 	lds	r26, 0x04DA	; 0x8004da <pxCurrentTCB>
    14e6:	b0 91 db 04 	lds	r27, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    14ea:	56 96       	adiw	r26, 0x16	; 22
    14ec:	3c 91       	ld	r19, X
    14ee:	85 e0       	ldi	r24, 0x05	; 5
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	83 1b       	sub	r24, r19
    14f4:	91 09       	sbc	r25, r1
    14f6:	95 87       	std	Z+13, r25	; 0x0d
    14f8:	84 87       	std	Z+12, r24	; 0x0c
    14fa:	30 e0       	ldi	r19, 0x00	; 0
    14fc:	c9 01       	movw	r24, r18
    14fe:	88 0f       	add	r24, r24
    1500:	99 1f       	adc	r25, r25
    1502:	88 0f       	add	r24, r24
    1504:	99 1f       	adc	r25, r25
    1506:	88 0f       	add	r24, r24
    1508:	99 1f       	adc	r25, r25
    150a:	28 0f       	add	r18, r24
    150c:	39 1f       	adc	r19, r25
    150e:	23 55       	subi	r18, 0x53	; 83
    1510:	3b 4f       	sbci	r19, 0xFB	; 251
    1512:	82 85       	ldd	r24, Z+10	; 0x0a
    1514:	93 85       	ldd	r25, Z+11	; 0x0b
    1516:	82 17       	cp	r24, r18
    1518:	93 07       	cpc	r25, r19
    151a:	19 f5       	brne	.+70     	; 0x1562 <vTaskPriorityInherit+0xac>
    151c:	8f 01       	movw	r16, r30
    151e:	ef 01       	movw	r28, r30
    1520:	22 96       	adiw	r28, 0x02	; 2
    1522:	ce 01       	movw	r24, r28
    1524:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    1528:	e0 91 da 04 	lds	r30, 0x04DA	; 0x8004da <pxCurrentTCB>
    152c:	f0 91 db 04 	lds	r31, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    1530:	86 89       	ldd	r24, Z+22	; 0x16
    1532:	f8 01       	movw	r30, r16
    1534:	86 8b       	std	Z+22, r24	; 0x16
    1536:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <uxTopReadyPriority>
    153a:	98 17       	cp	r25, r24
    153c:	10 f4       	brcc	.+4      	; 0x1542 <vTaskPriorityInherit+0x8c>
    153e:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <uxTopReadyPriority>
    1542:	90 e0       	ldi	r25, 0x00	; 0
    1544:	9c 01       	movw	r18, r24
    1546:	22 0f       	add	r18, r18
    1548:	33 1f       	adc	r19, r19
    154a:	22 0f       	add	r18, r18
    154c:	33 1f       	adc	r19, r19
    154e:	22 0f       	add	r18, r18
    1550:	33 1f       	adc	r19, r19
    1552:	82 0f       	add	r24, r18
    1554:	93 1f       	adc	r25, r19
    1556:	be 01       	movw	r22, r28
    1558:	83 55       	subi	r24, 0x53	; 83
    155a:	9b 4f       	sbci	r25, 0xFB	; 251
    155c:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    1560:	07 c0       	rjmp	.+14     	; 0x1570 <vTaskPriorityInherit+0xba>
    1562:	a0 91 da 04 	lds	r26, 0x04DA	; 0x8004da <pxCurrentTCB>
    1566:	b0 91 db 04 	lds	r27, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    156a:	56 96       	adiw	r26, 0x16	; 22
    156c:	8c 91       	ld	r24, X
    156e:	86 8b       	std	Z+22, r24	; 0x16
    1570:	df 91       	pop	r29
    1572:	cf 91       	pop	r28
    1574:	1f 91       	pop	r17
    1576:	0f 91       	pop	r16
    1578:	08 95       	ret

0000157a <xTaskPriorityDisinherit>:
    157a:	0f 93       	push	r16
    157c:	1f 93       	push	r17
    157e:	cf 93       	push	r28
    1580:	df 93       	push	r29
    1582:	fc 01       	movw	r30, r24
    1584:	89 2b       	or	r24, r25
    1586:	79 f1       	breq	.+94     	; 0x15e6 <xTaskPriorityDisinherit+0x6c>
    1588:	84 a1       	ldd	r24, Z+36	; 0x24
    158a:	81 50       	subi	r24, 0x01	; 1
    158c:	84 a3       	std	Z+36, r24	; 0x24
    158e:	26 89       	ldd	r18, Z+22	; 0x16
    1590:	93 a1       	ldd	r25, Z+35	; 0x23
    1592:	29 17       	cp	r18, r25
    1594:	51 f1       	breq	.+84     	; 0x15ea <xTaskPriorityDisinherit+0x70>
    1596:	81 11       	cpse	r24, r1
    1598:	2a c0       	rjmp	.+84     	; 0x15ee <xTaskPriorityDisinherit+0x74>
    159a:	ef 01       	movw	r28, r30
    159c:	8f 01       	movw	r16, r30
    159e:	0e 5f       	subi	r16, 0xFE	; 254
    15a0:	1f 4f       	sbci	r17, 0xFF	; 255
    15a2:	c8 01       	movw	r24, r16
    15a4:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    15a8:	8b a1       	ldd	r24, Y+35	; 0x23
    15aa:	8e 8b       	std	Y+22, r24	; 0x16
    15ac:	25 e0       	ldi	r18, 0x05	; 5
    15ae:	30 e0       	ldi	r19, 0x00	; 0
    15b0:	28 1b       	sub	r18, r24
    15b2:	31 09       	sbc	r19, r1
    15b4:	3d 87       	std	Y+13, r19	; 0x0d
    15b6:	2c 87       	std	Y+12, r18	; 0x0c
    15b8:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <uxTopReadyPriority>
    15bc:	98 17       	cp	r25, r24
    15be:	10 f4       	brcc	.+4      	; 0x15c4 <xTaskPriorityDisinherit+0x4a>
    15c0:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <uxTopReadyPriority>
    15c4:	90 e0       	ldi	r25, 0x00	; 0
    15c6:	9c 01       	movw	r18, r24
    15c8:	22 0f       	add	r18, r18
    15ca:	33 1f       	adc	r19, r19
    15cc:	22 0f       	add	r18, r18
    15ce:	33 1f       	adc	r19, r19
    15d0:	22 0f       	add	r18, r18
    15d2:	33 1f       	adc	r19, r19
    15d4:	82 0f       	add	r24, r18
    15d6:	93 1f       	adc	r25, r19
    15d8:	b8 01       	movw	r22, r16
    15da:	83 55       	subi	r24, 0x53	; 83
    15dc:	9b 4f       	sbci	r25, 0xFB	; 251
    15de:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    15e2:	81 e0       	ldi	r24, 0x01	; 1
    15e4:	05 c0       	rjmp	.+10     	; 0x15f0 <xTaskPriorityDisinherit+0x76>
    15e6:	80 e0       	ldi	r24, 0x00	; 0
    15e8:	03 c0       	rjmp	.+6      	; 0x15f0 <xTaskPriorityDisinherit+0x76>
    15ea:	80 e0       	ldi	r24, 0x00	; 0
    15ec:	01 c0       	rjmp	.+2      	; 0x15f0 <xTaskPriorityDisinherit+0x76>
    15ee:	80 e0       	ldi	r24, 0x00	; 0
    15f0:	df 91       	pop	r29
    15f2:	cf 91       	pop	r28
    15f4:	1f 91       	pop	r17
    15f6:	0f 91       	pop	r16
    15f8:	08 95       	ret

000015fa <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    15fa:	80 91 da 04 	lds	r24, 0x04DA	; 0x8004da <pxCurrentTCB>
    15fe:	90 91 db 04 	lds	r25, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    1602:	89 2b       	or	r24, r25
    1604:	39 f0       	breq	.+14     	; 0x1614 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1606:	e0 91 da 04 	lds	r30, 0x04DA	; 0x8004da <pxCurrentTCB>
    160a:	f0 91 db 04 	lds	r31, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
    160e:	84 a1       	ldd	r24, Z+36	; 0x24
    1610:	8f 5f       	subi	r24, 0xFF	; 255
    1612:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    1614:	80 91 da 04 	lds	r24, 0x04DA	; 0x8004da <pxCurrentTCB>
    1618:	90 91 db 04 	lds	r25, 0x04DB	; 0x8004db <pxCurrentTCB+0x1>
	}
    161c:	08 95       	ret

0000161e <memcpy>:
    161e:	fb 01       	movw	r30, r22
    1620:	dc 01       	movw	r26, r24
    1622:	02 c0       	rjmp	.+4      	; 0x1628 <memcpy+0xa>
    1624:	01 90       	ld	r0, Z+
    1626:	0d 92       	st	X+, r0
    1628:	41 50       	subi	r20, 0x01	; 1
    162a:	50 40       	sbci	r21, 0x00	; 0
    162c:	d8 f7       	brcc	.-10     	; 0x1624 <memcpy+0x6>
    162e:	08 95       	ret

00001630 <_exit>:
    1630:	f8 94       	cli

00001632 <__stop_program>:
    1632:	ff cf       	rjmp	.-2      	; 0x1632 <__stop_program>
